# Chapter 09: SQL & Neon PostgreSQL with Python - Implementation Plan

**Generated by**: chapter-planner v2.0.0 (Reasoning-Activated)
**Source Spec**: specs/chapter-09-sql-neon/spec.md
**Expertise Skill**: .claude/skills/building-with-sqlalchemy-orm/SKILL.md
**Created**: 2026-02-06
**Constitution**: v6.0.0 (Reasoning Mode)

---

## I. Chapter Analysis

### Chapter Type

**Technical/Code-Focused** - This chapter focuses on building skills/implementation with learning objectives using "apply/create/implement". Code examples are central to every lesson. Uses sequential lesson structure (L0-L7) with hands-on coding exercises.

**Reasoning**: Spec learning outcomes include "Apply: Define data models as Python classes, perform CRUD operations safely" and "Build: Create a multi-table application (Budget Tracker)". Every lesson involves writing and testing Python code.

### Concept Density Analysis

**Core Concepts** (from spec): 11 concepts

1. Relational database paradigm (why databases beat files)
2. Tables, rows, columns (schema fundamentals)
3. ORM abstraction (Python classes as tables)
4. Session/Unit of Work pattern
5. CRUD operations (Create, Read, Update, Delete)
6. Foreign keys and relationships (one-to-many)
7. Queries (filtering, ordering, joining)
8. Transactions and atomicity
9. Rollback and error recovery
10. Neon serverless PostgreSQL (connection strings, pooling)
11. Environment variables and secrets management

**Complexity Assessment**: Standard (6-8 concepts per chapter threshold, but stretched to 11 due to comprehensive database coverage)

**Proficiency Tier**: A1-A2 (from spec: "CEFR Proficiency: A1-A2 (Beginners, foundational practical skills)")

**Justified Lesson Count**: 8 lessons (L0-L7)

| Layer | Lessons | Concepts Covered | Reasoning |
|-------|---------|------------------|-----------|
| Setup (L0) | 1 lesson | Skill ownership, doc fetching | Meta-learning foundation |
| L1 (Manual) | 3 lessons (L1-L3) | Concepts 1-5 | Build manual foundation before AI |
| L2 (Collaboration) | 3 lessons (L4-L6) | Concepts 6-10 | AI assists with complexity |
| L3 (Skill) | 1 lesson (L7) | Concept 11 + integration | Capstone with reusable skill |

**Total**: 8 lessons (justified by concept density + A1-A2 proficiency requiring thorough scaffolding)

---

## II. Success Evals (from Spec)

**Predefined Success Criteria** (evals-first requirement):

1. **SC-1**: Students can define a data model (Python classes that map to database tables, include relationships, predict what tables/columns will be created)
2. **SC-2**: Students can perform safe CRUD (Create, Read, Update, Delete with transactions)
3. **SC-3**: Students connect to Neon successfully (account, connection string, env vars, test query)
4. **SC-4**: Students build and deploy Budget Tracker (multi-table, complex queries, transactions)
5. **SC-5**: Students own a reusable database skill (created in L0, improved throughout, references official docs)

**All lessons below map to these evals.**

---

## III. Pedagogical Arc

```
Foundation        Practice         Integration        Mastery
[L0-L1]      →   [L2-L3]     →    [L4-L6]       →   [L7]

Skill-First       Building         Real Database      Capstone
Why Databases     CRUD & Models    Relationships      Full App
                                   Transactions
                                   Neon Connection
```

### Layer Progression Applied

| Lessons | Layer | Description | AI Role |
|---------|-------|-------------|---------|
| L0 | Setup | Build personal skill, fetch docs | AI fetches Context7/official docs |
| L1-L3 | L1 (Manual) | Manual code writing, understand patterns | NO AI assistance yet |
| L4-L6 | L2 (Collaboration) | Same tasks with AI assistance, Three Roles | AI as Teacher/Student/Co-Worker |
| L7 | L3 (Skill) | Capstone with composed skills | AI orchestrates full implementation |

---

## IV. Lesson Sequence

### Lesson 0: Build Your Database Skill (Setup Layer)

**Learning Objective**: Create a personal `database-deployment` skill that references official SQLAlchemy + Neon documentation and will improve throughout the chapter

**Stage**: 0 (Setup - Meta-Learning)

**CEFR Proficiency**: A1

**New Concepts** (count: 3):
1. Skill ownership ("I own my learning")
2. Official documentation fetching (Context7, docs.sqlalchemy.org)
3. Skill structure (Persona, When to Use, Workflow)

**Cognitive Load Validation**: 3 concepts <= 7 (A2 limit) -> WITHIN LIMIT

**Maps to Evals**: SC-5

**Content Elements**:
- Create `.claude/skills/database-deployment/SKILL.md` directory structure
- Fetch official SQLAlchemy quickstart via Context7
- Fetch Neon getting-started docs
- Write initial Persona: "I'm learning to build data-persistent applications"
- Document initial "When to Use": "When I need to store data long-term"

**"Try With AI" Prompts**:
1. "Fetch the SQLAlchemy ORM quickstart from docs.sqlalchemy.org and summarize the three most important concepts for a beginner"
   - *What you're learning*: How to use AI to gather authoritative documentation
2. "What is the difference between ORM and raw SQL? Give me a one-sentence explanation I can add to my skill"
   - *What you're learning*: How to use AI to clarify concepts for your own notes
3. "Create a starter `SKILL.md` for database-deployment with Persona, When to Use, and Core Concepts sections based on what we've learned"
   - *What you're learning*: How to use AI to scaffold your learning artifacts

**Prerequisites**: None (first lesson of chapter)

**Estimated Duration**: 20 minutes

**Success Checkpoint**: Student has created `.claude/skills/database-deployment/SKILL.md` with initial Persona and references to official docs

---

### Lesson 1: From CSV to Databases (Layer 1: Manual Foundation)

**Learning Objective**: Explain why relational databases solve problems that files cannot, and recognize the database paradigm shift

**Stage**: 1 (Manual Foundation)

**CEFR Proficiency**: A1

**New Concepts** (count: 4):
1. The persistence problem (why files fail at scale)
2. Tables, rows, columns (database vocabulary)
3. Schema concept (structure before data)
4. Query capability (asking questions of data)

**Cognitive Load Validation**: 4 concepts <= 7 (A2 limit) -> WITHIN LIMIT

**Maps to Evals**: SC-1 (foundation)

**Content Elements**:
- **Narrative hook**: Your tax script from Ch8 works... once. What about 10 years of data? What about "show me February spending by category"?
- **CSV limitations exercise**: Try to answer "What was my average monthly grocery spending in 2025?" with CSV files
- **Database paradigm**: Tables are like CSVs with superpowers (relationships, queries, transactions)
- **Schema exercise**: Draw a paper schema for Budget Tracker (expenses table: id, description, amount, date, category)
- **NO CODE YET** - conceptual foundation

**"Try With AI" Prompts**:
1. "I have 5 years of bank statements in CSV files. What questions would be hard to answer with CSV that a database could answer easily?"
   - *What you're learning*: Recognizing database use cases
2. "Explain the difference between 'data' and 'schema' using a library analogy"
   - *What you're learning*: Building mental models for database concepts
3. "What would a schema for a Budget Tracker look like? I need to track expenses, categories, and maybe users"
   - *What you're learning*: Designing before building

**Prerequisites**: Chapter 8 (file processing, CSV experience)

**Estimated Duration**: 20 minutes

**Success Checkpoint**: Student can explain why CSV is insufficient for persistent data queries and can sketch a table schema on paper

---

### Lesson 2: Models as Code (Layer 1: Manual Foundation)

**Learning Objective**: Define SQLAlchemy ORM models as Python classes that map to database tables

**Stage**: 1 (Manual Foundation)

**CEFR Proficiency**: A1

**New Concepts** (count: 5):
1. ORM = Object-Relational Mapping (Python classes are tables)
2. `Base = declarative_base()` pattern
3. `Column` types (Integer, String, Float, DateTime)
4. `__tablename__` attribute
5. Primary keys (`id = Column(Integer, primary_key=True)`)

**Cognitive Load Validation**: 5 concepts <= 7 (A2 limit) -> WITHIN LIMIT

**Maps to Evals**: SC-1

**Content Elements**:
- **Bridge from L1**: "We designed a schema on paper. Now we write it in Python."
- **Manual typing exercise**: Students type out the Expense model character by character
  ```python
  from sqlalchemy import Column, Integer, String, Float, DateTime
  from sqlalchemy.orm import declarative_base
  from datetime import datetime

  Base = declarative_base()

  class Expense(Base):
      __tablename__ = 'expenses'

      id = Column(Integer, primary_key=True)
      description = Column(String(200))
      amount = Column(Float)
      date = Column(DateTime, default=datetime.utcnow)
  ```
- **Second model**: Category (simpler - just id and name)
- **Prediction exercise**: "What columns will this create in the database?"
- **No database connection yet** - just model definition

**"Try With AI" Prompts**:
1. "I just wrote this model. Explain what each line does, especially `declarative_base()` and `__tablename__`"
   - *What you're learning*: How to use AI to explain code you've written
2. "What Column type should I use for money amounts - Float or something else? What are the tradeoffs?"
   - *What you're learning*: How to use AI for design decisions
3. "Add a `created_at` timestamp that defaults to the current time when an expense is created"
   - *What you're learning*: How to extend models with AI guidance

**Prerequisites**: L1 (schema concepts)

**Estimated Duration**: 25 minutes

**Success Checkpoint**: Student can write Expense and Category models from scratch and predict the resulting table structure

---

### Lesson 3: Creating & Reading Data (Layer 1: Manual Foundation)

**Learning Objective**: Perform first CRUD operations (Create and Read) using SQLAlchemy sessions

**Stage**: 1 (Manual Foundation)

**CEFR Proficiency**: A2

**New Concepts** (count: 6):
1. Engine creation (`create_engine()`)
2. Table creation (`Base.metadata.create_all()`)
3. Session as unit of work (context manager pattern)
4. `session.add()` for Create
5. `session.query()` for Read
6. `session.commit()` to save changes

**Cognitive Load Validation**: 6 concepts <= 7 (A2 limit) -> WITHIN LIMIT

**Maps to Evals**: SC-2

**Content Elements**:
- **In-memory SQLite for testing**: No Neon setup yet, use `sqlite:///budget.db`
- **Manual typing exercise**: Create engine, create tables
  ```python
  from sqlalchemy import create_engine

  engine = create_engine('sqlite:///budget.db')
  Base.metadata.create_all(engine)
  ```
- **Create first expense** (manual typing):
  ```python
  from sqlalchemy.orm import Session

  with Session(engine) as session:
      expense = Expense(description="Coffee", amount=4.50)
      session.add(expense)
      session.commit()
      print(f"Created expense with ID: {expense.id}")
  ```
- **Query expenses** (manual typing):
  ```python
  with Session(engine) as session:
      expenses = session.query(Expense).all()
      for e in expenses:
          print(f"{e.description}: ${e.amount}")
  ```
- **Filtering exercise**: Query expenses > $10

**"Try With AI" Prompts**:
1. "I created an expense but I'm not sure if it was saved. How do I verify it's in the database?"
   - *What you're learning*: Verification patterns (Principle 3)
2. "What happens if I forget to call `session.commit()`? What about if I forget to close the session?"
   - *What you're learning*: Understanding session lifecycle
3. "Write a query that finds all expenses greater than $50, sorted by amount descending"
   - *What you're learning*: Query composition

**Prerequisites**: L2 (model definition)

**Estimated Duration**: 25 minutes

**Success Checkpoint**: Student can create 5+ expenses and query them back with filters

---

### Lesson 4: Relationships (Layer 2: AI Collaboration)

**Learning Objective**: Define foreign key relationships between tables and perform multi-table queries using AI collaboration

**Stage**: 2 (AI Collaboration with Three Roles)

**CEFR Proficiency**: A2

**New Concepts** (count: 5):
1. Foreign keys (`ForeignKey('categories.id')`)
2. `relationship()` for navigation
3. `back_populates` for bidirectional access
4. Join queries
5. Navigating relationships (`expense.category.name`)

**Cognitive Load Validation**: 5 concepts <= 7 (A2 limit) -> WITHIN LIMIT

**Maps to Evals**: SC-1, SC-4

**Three Roles Demonstrations** (REQUIRED):

**Role 1: AI as Teacher**
- **Scenario**: Student has Expense and Category models but doesn't know how to connect them
- **AI suggests**: "Add a `category_id` ForeignKey column to Expense and a `relationship()` to both models. Here's the pattern..."
- **What student learns**: The bidirectional relationship pattern they didn't know

**Role 2: AI as Student**
- **Scenario**: AI generates a complex join query with eager loading
- **Student responds**: "Too complex for now. Just show me basic navigation with `expense.category.name`"
- **AI adapts**: Simplifies to basic relationship traversal

**Role 3: AI as Co-Worker**
- **Scenario**: Building a query to show expenses by category
- **Iteration 1**: AI generates `session.query(Category).join(Expense)`
- **Student feedback**: "I need the expense amounts too, not just categories"
- **Iteration 2**: AI adjusts to include `func.sum(Expense.amount)`
- **Convergence**: Together they build the category totals query

**Content Elements**:
- **Model update**: Add `category_id` to Expense, add relationship to both
  ```python
  class Category(Base):
      __tablename__ = 'categories'
      id = Column(Integer, primary_key=True)
      name = Column(String(50), unique=True)
      expenses = relationship("Expense", back_populates="category")

  class Expense(Base):
      __tablename__ = 'expenses'
      # ... existing columns ...
      category_id = Column(Integer, ForeignKey('categories.id'))
      category = relationship("Category", back_populates="expenses")
  ```
- **Create categories**: Food, Transportation, Entertainment
- **Create expenses with categories**
- **Navigate relationships**: Access `expense.category.name`
- **Join query**: Total spent per category

**"Try With AI" Prompts**:
1. "I have Expense and Category models. Show me how to connect them with a foreign key relationship"
   - *What you're learning*: AI as Teacher (new pattern)
2. "This join query is too complex. Simplify it to just show each expense with its category name"
   - *What you're learning*: AI as Student (you refine AI output)
3. "Let's build a query together that shows total spending by category. Start with the basic structure and I'll refine it"
   - *What you're learning*: AI as Co-Worker (iterate together)

**Prerequisites**: L3 (basic CRUD)

**Estimated Duration**: 30 minutes

**Success Checkpoint**: Student can write a join query that shows total spending per category

---

### Lesson 5: Transactions & Atomicity (Layer 2: AI Collaboration)

**Learning Objective**: Implement transaction handling that guarantees atomicity (all-or-nothing) and proper error recovery

**Stage**: 2 (AI Collaboration with Three Roles)

**CEFR Proficiency**: A2

**New Concepts** (count: 5):
1. Atomicity (all-or-nothing principle)
2. `session.commit()` as finalization
3. `session.rollback()` on error
4. try/except pattern for transactions
5. Why partial saves corrupt data

**Cognitive Load Validation**: 5 concepts <= 7 (A2 limit) -> WITHIN LIMIT

**Maps to Evals**: SC-2, SC-4

**Three Roles Demonstrations** (REQUIRED):

**Role 1: AI as Teacher**
- **Scenario**: Student writes code that commits after each operation
- **AI suggests**: "This is dangerous! If the second commit fails, you have partial data. Wrap both in one transaction with try/except/rollback"
- **What student learns**: The transaction pattern for atomicity

**Role 2: AI as Student**
- **Scenario**: AI suggests complex savepoint pattern
- **Student responds**: "Just show me basic try/except/rollback for now"
- **AI adapts**: Simplifies to single-level transaction handling

**Role 3: AI as Co-Worker**
- **Scenario**: Building a "transfer between categories" function
- **Iteration 1**: AI writes basic debit/credit
- **Student feedback**: "What if the category doesn't exist?"
- **Iteration 2**: AI adds validation and meaningful error messages
- **Convergence**: Together they build robust transfer function

**Content Elements**:
- **Bad pattern demonstration**:
  ```python
  # ❌ WRONG: Partial save if second fails
  session.add(expense1)
  session.commit()
  session.add(expense2)
  session.commit()  # What if this fails?
  ```
- **Good pattern**:
  ```python
  # ✅ RIGHT: All or nothing
  try:
      session.add(expense1)
      session.add(expense2)
      session.commit()
  except Exception as e:
      session.rollback()
      print(f"Transaction failed: {e}")
  ```
- **Exercise**: Implement transfer_expense function that moves expense between categories atomically
- **Verification**: Deliberately cause error (invalid category) and verify rollback

**"Try With AI" Prompts**:
1. "My code saves expense1 then expense2 separately. What's wrong with this pattern? Show me the safe way"
   - *What you're learning*: AI as Teacher (transaction pattern)
2. "This transaction pattern is complex. Just show me basic try/except/rollback"
   - *What you're learning*: AI as Student (simplify)
3. "Let's build a function that transfers an expense to a different category. Help me handle the error cases"
   - *What you're learning*: AI as Co-Worker (iterate on edge cases)

**Prerequisites**: L4 (relationships - needed for category validation)

**Estimated Duration**: 30 minutes

**Success Checkpoint**: Student can implement a function that rolls back on error and never leaves partial data

---

### Lesson 6: Connecting to Neon (Layer 2: AI Collaboration)

**Learning Objective**: Configure and connect to Neon PostgreSQL with proper environment variable handling and connection pooling

**Stage**: 2 (AI Collaboration with Three Roles)

**CEFR Proficiency**: A2

**New Concepts** (count: 6):
1. Neon serverless PostgreSQL (what it is, why it matters)
2. Connection string format (`postgresql+psycopg2://...`)
3. Environment variables (`.env` file, `os.getenv()`)
4. SSL requirement (`?sslmode=require`)
5. Connection pooling (`pool_size`, `pool_pre_ping`)
6. Never hardcode credentials

**Cognitive Load Validation**: 6 concepts <= 7 (A2 limit) -> WITHIN LIMIT

**Maps to Evals**: SC-3

**Three Roles Demonstrations** (REQUIRED):

**Role 1: AI as Teacher**
- **Scenario**: Student doesn't know where to get connection string
- **AI suggests**: "Go to Neon dashboard > Project > Connection tab. Copy the connection string. It includes your password so never commit it to git"
- **What student learns**: Neon setup workflow

**Role 2: AI as Student**
- **Scenario**: AI provides complex pooling configuration
- **Student responds**: "Just show me the minimum config to connect"
- **AI adapts**: Simplifies to basic engine with `pool_pre_ping=True` only

**Role 3: AI as Co-Worker**
- **Scenario**: Connection fails with error
- **Iteration 1**: AI suggests checking connection string format
- **Student feedback**: "Format looks right but still failing"
- **Iteration 2**: AI suggests testing with simpler query
- **Convergence**: Together they debug and verify connection

**Content Elements**:
- **Neon account creation**: 2-minute walkthrough
- **Connection string**: Copy from dashboard, understand format
- **Environment setup**:
  ```python
  # .env file (never commit!)
  DATABASE_URL=postgresql+psycopg2://user:pass@ep-ABC123.neon.tech/dbname?sslmode=require
  ```
  ```python
  # Python code
  from dotenv import load_dotenv
  import os

  load_dotenv()
  DATABASE_URL = os.getenv("DATABASE_URL")
  engine = create_engine(DATABASE_URL, pool_pre_ping=True)
  ```
- **Verification**: Test query to confirm connection
- **Troubleshooting guide**: Common errors and fixes

**"Try With AI" Prompts**:
1. "How do I get my Neon connection string? Walk me through the steps"
   - *What you're learning*: AI as Teacher (setup workflow)
2. "This pooling config is complex. What's the minimum I need for a learning project?"
   - *What you're learning*: AI as Student (simplify)
3. "My connection is failing with 'server closed the connection unexpectedly'. Let's debug together"
   - *What you're learning*: AI as Co-Worker (troubleshooting)

**Prerequisites**: L5 (transactions - we'll use Neon for remaining exercises)

**Estimated Duration**: 25 minutes

**Success Checkpoint**: Student can connect to Neon and run a test query successfully

---

### Lesson 7: Capstone - Budget Tracker (Layer 3: Skill Building)

**Learning Objective**: Build a complete Budget Tracker application with multi-table queries, monthly summaries, and reporting, using your accumulated database skill

**Stage**: 3 (Skill Building - Capstone)

**CEFR Proficiency**: A2

**New Concepts** (count: 4):
1. Multi-table aggregations (`func.sum()`, `func.count()`, `group_by()`)
2. Date filtering (monthly reports)
3. Complex query composition
4. Application structure (class-based organization)

**Cognitive Load Validation**: 4 concepts <= 7 (A2 limit) -> WITHIN LIMIT

**Maps to Evals**: SC-4, SC-5 (all evals integrated)

**Content Elements**:
- **Full Budget Tracker implementation**:
  - Models: User, Category, Expense (all connected)
  - BudgetManager class with methods:
    - `add_expense(user_id, description, amount, category_name)`
    - `get_monthly_summary(user_id, year, month)`
    - `get_category_totals(user_id)`
    - `delete_expense(expense_id)`
- **Complex queries**:
  ```python
  def get_monthly_summary(self, user_id, year, month):
      from datetime import date
      with Session(self.engine) as session:
          start_date = date(year, month, 1)
          end_date = date(year, month + 1, 1) if month < 12 else date(year + 1, 1, 1)

          results = session.query(
              Category.name,
              func.sum(Expense.amount).label('total'),
              func.count(Expense.id).label('count')
          ).join(Expense).filter(
              Expense.user_id == user_id,
              Expense.date >= start_date,
              Expense.date < end_date
          ).group_by(Category.name).all()

          return [{"category": name, "total": float(total or 0), "count": count}
                  for name, total, count in results]
  ```
- **Skill finalization**: Update `database-deployment` skill with:
  - Completed Persona
  - Decision Logic (when to use transactions, when to batch)
  - Workflow (Define model -> Connect -> CRUD -> Query -> Test)
  - References (what you learned)
  - Examples (Budget Tracker as portfolio piece)

**"Try With AI" Prompts**:
1. "Help me build a `get_monthly_summary` function that returns spending by category for a specific month"
   - *What you're learning*: Complex query composition with AI assistance
2. "Review my Budget Tracker implementation. What error cases am I missing?"
   - *What you're learning*: AI for code review and edge cases
3. "Help me finalize my `database-deployment` skill. Add the Decision Logic section based on what I learned"
   - *What you're learning*: Skill improvement with AI collaboration

**Prerequisites**: L0-L6 (all prior lessons - accumulated knowledge)

**Estimated Duration**: 40 minutes

**Success Checkpoint**: Student has working Budget Tracker that generates monthly spending reports and a finalized personal database skill

---

## V. Skill Dependencies

**Skill Dependency Graph**:

```
[L0: Skill structure] (no prerequisites)
    ↓
[L1: Database concepts] (requires L0 for skill context)
    ↓
[L2: ORM models] (requires L1 for schema understanding)
    ↓
[L3: CRUD operations] (requires L2 for model definitions)
    ↓
[L4: Relationships] (requires L3 for CRUD to test relationships)
    ↓
[L5: Transactions] (requires L4 for multi-table operations)
    ↓
[L6: Neon connection] (requires L5 for meaningful operations)
    ↓
[L7: Capstone] (requires L0-L6 - all accumulated knowledge)
```

**Cross-Chapter Dependencies**:
- Chapter 8 (Data Extraction): Students know file processing, CSV handling
- Chapter 3 (Python Fundamentals): Variables, functions, error handling
- Chapter 7 (File Processing): Directory navigation, batch operations

**Validation**: Prerequisites are implemented chapters -> CONFIRMED

---

## VI. Cognitive Load Analysis

| Lesson | New Concepts | Tier Limit | Status | Notes |
|--------|-------------|------------|--------|-------|
| L0 | 3 | 7 (A2) | WITHIN | Meta-learning, low cognitive load |
| L1 | 4 | 7 (A2) | WITHIN | Conceptual only, no code yet |
| L2 | 5 | 7 (A2) | WITHIN | Code typing, but familiar Python |
| L3 | 6 | 7 (A2) | WITHIN | Hitting limit but manageable |
| L4 | 5 | 7 (A2) | WITHIN | AI assistance reduces load |
| L5 | 5 | 7 (A2) | WITHIN | Pattern-based, AI assists |
| L6 | 6 | 7 (A2) | WITHIN | Setup-focused, less abstract |
| L7 | 4 | 7 (A2) | WITHIN | Synthesis, not new learning |

**Assessment**: All lessons within A1-A2 cognitive load limits. No lesson exceeds 7 new concepts.

---

## VII. "Try With AI" Prompt Strategy

| Lesson | AI Role | Prompt Focus |
|--------|---------|--------------|
| L0 | Doc Fetcher | Gather authoritative sources, scaffold skill |
| L1 | Conceptual Clarifier | Explain database paradigm, design decisions |
| L2 | Code Explainer | Explain written code, suggest extensions |
| L3 | Pattern Teacher | Verification patterns, query building |
| L4 | Teacher/Student/Co-Worker | Relationship patterns, query refinement |
| L5 | Teacher/Student/Co-Worker | Transaction safety, error handling |
| L6 | Teacher/Student/Co-Worker | Setup workflow, troubleshooting |
| L7 | Complex Query Partner | Aggregations, code review, skill finalization |

**Prompt Count**: 3 prompts per lesson = 24 total prompts

---

## VIII. Activity/Exercise Progression

| Lesson | Activity | Builds Toward |
|--------|----------|---------------|
| L0 | Create skill directory and SKILL.md | Skill ownership |
| L1 | Paper schema design, CSV limitations exercise | Understanding |
| L2 | Type Expense and Category models | Model definition |
| L3 | Create 5 expenses, query with filters | CRUD fluency |
| L4 | Connect models with relationships, join query | Multi-table queries |
| L5 | Implement transfer function with rollback | Transaction safety |
| L6 | Connect to Neon, verify with test query | Real deployment |
| L7 | Build full BudgetManager, generate report | Capstone integration |

**Safe Failure Contexts**:
- L1-L5: SQLite (local, disposable)
- L6-L7: Neon free tier (isolated, can recreate)

---

## IX. Assessment Points

| Lesson | Assessment | Success Criteria |
|--------|------------|------------------|
| L0 | Skill file exists | `ls .claude/skills/database-deployment/SKILL.md` returns file |
| L1 | Explain CSV vs DB | Student articulates 3+ limitations of CSV |
| L2 | Model prediction | Student predicts table structure before running code |
| L3 | Query results | Student retrieves filtered expenses correctly |
| L4 | Join query works | Category totals query returns expected results |
| L5 | Rollback verification | Intentionally fail transaction, verify no data corrupted |
| L6 | Neon connection | `SELECT 1` returns successfully from Neon |
| L7 | Monthly report | `get_monthly_summary()` returns correct totals |

---

## X. Content Dependencies and Ordering

### Why This Order?

| Transition | Reasoning |
|------------|-----------|
| L0 -> L1 | Skill context before concepts |
| L1 -> L2 | Conceptual understanding before code |
| L2 -> L3 | Model definition before operations |
| L3 -> L4 | Single-table CRUD before multi-table |
| L4 -> L5 | Relationships before transaction complexity |
| L5 -> L6 | Safe operations before real database |
| L6 -> L7 | Connection before capstone integration |

### Critical Path

```
L2 (Models) -> L3 (CRUD) -> L4 (Relationships) -> L7 (Capstone)
```

If any lesson in critical path is skipped, capstone cannot succeed.

---

## XI. Validation Checklist

**Chapter-Level Validation**:
- [x] Chapter type identified (Technical/Code-Focused)
- [x] Concept density analysis documented (11 concepts)
- [x] Lesson count justified (8 lessons = L0-L7)
- [x] All evals from spec covered by lessons
- [x] All lessons map to at least one eval

**Stage Progression Validation**:
- [x] L0: Setup (skill creation)
- [x] L1-L3: Layer 1 (Manual, no AI assistance in code)
- [x] L4-L6: Layer 2 (AI Collaboration with Three Roles)
- [x] L7: Layer 3 (Skill Building capstone)
- [x] No spec-first before Layer 3

**Cognitive Load Validation**:
- [x] Each lesson's concept count <= A2 tier limit (7)
- [x] No lesson exceeds 6 new concepts
- [x] AI assistance in L2 layer reduces cognitive load

**Dependency Validation**:
- [x] Skill dependencies satisfied by lesson order
- [x] Cross-chapter dependencies validated (Ch 3, 7, 8 implemented)

**Three Roles Validation** (Layer 2 lessons):
- [x] L4: Demonstrates AI as Teacher, Student, Co-Worker
- [x] L5: Demonstrates AI as Teacher, Student, Co-Worker
- [x] L6: Demonstrates AI as Teacher, Student, Co-Worker

---

## XII. Expertise Skill Integration

**Source**: `.claude/skills/building-with-sqlalchemy-orm/SKILL.md`

| Lesson | Skill Reference Used |
|--------|---------------------|
| L2 | Core Concepts: Models as Classes |
| L3 | Workflow: Steps 3 (CRUD) from SKILL.md |
| L4 | Core Concepts: Relationships (from SKILL.md) |
| L5 | references/transactions.md patterns |
| L6 | references/neon-setup.md configuration |
| L7 | Complete Budget Tracker example |

**All code examples pulled from verified expertise skill - no hallucinated APIs.**

---

## XIII. Quality Reference Alignment

**Structure Match**: Chapter 8 README.md
- Lesson table with duration, key skill
- Seven Principles alignment section
- Prerequisites clearly stated
- Journey overview before lessons

**Duration Pattern**: 15-40 minutes per lesson (matches Part 2 pedagogy)

**Code Quality**: All examples from expertise skill references

---

## XIV. Differentiation Paths

**For Advanced Students**:
- L4: Implement many-to-many (User has many Categories)
- L6: Configure advanced pooling (pool_size, max_overflow)
- L7: Add MCP integration for agent queries

**For Struggling Students**:
- L3: Use provided CRUD function templates, focus on understanding
- L4: Skip join queries initially, use basic relationship navigation
- L5: Focus only on try/except/rollback, skip savepoints
- L7: Complete partial capstone (only CRUD, skip aggregations)

---

## XV. Next Steps

1. **Implementation**: Use `content-implementer` subagent with this plan
2. **Validation**: Run `educational-validator` on each lesson
3. **Fact-Check**: Run `factual-verifier` on code examples
4. **Chapter 9 Bridge**: Ensure Budget Tracker data structure supports financial analysis

---

## XVI. Revision History

- **v1.0** (2026-02-06): Initial plan from spec analysis
  - 8 lessons (L0-L7)
  - Layer progression: Setup -> L1 (Manual) -> L2 (Collaboration) -> L3 (Skill)
  - All success criteria mapped to lessons
  - Three Roles demonstrations planned for L4-L6
  - Cognitive load validated for A1-A2 proficiency
