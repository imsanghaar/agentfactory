# Implementation Plan: Linux Mastery for Digital FTEs v2.0

**Branch**: `001-linux-mastery-v2` | **Date**: 2026-02-08 | **Spec**: `specs/001-linux-mastery-v2/spec.md`
**Generated by**: chapter-planner (Reasoning-Activated)
**Constitution**: v7.0.0 (Agent Factory Paradigm)

---

## I. Chapter Analysis

### Chapter Type

**Technical/Code-Focused** -- Learning objectives use "apply/create/implement", code examples required throughout, hands-on CLI exercises in every lesson. Structure: Sequential lessons with hands-on discovery modality.

### Concept Density Analysis

**Core Concepts** (from spec): 72 concepts across 13 lessons (average 5.5 per lesson)

**Complexity Assessment**: Standard-to-Complex (mix of simple CLI operations and sophisticated systems administration)

**Proficiency Tier**: B1 (lessons 1-4) -> B2 (lessons 5-11) -> C1 (lessons 12-14) per spec FR-003

**Justified Lesson Count**: 13 lessons + 1 quiz

Reasoning: The spec identifies 21 issues with v1's 9-lesson structure. Four critical topic gaps (file operations, text editing/pipes, networking/SSH, and splitting 2 overloaded lessons) justify 4 additional lessons. The 13-lesson count is driven by:
- 4 new foundational topics missing from v1
- 2 splits of oversized lessons (old L4 at 34KB, old L8 at 48KB)
- CEFR cognitive load limit of 6 concepts/lesson
- 4-Layer progression requiring adequate L1 foundation (4 lessons) before L2 (7 lessons)

### Layer Distribution

| Layer | Lessons | Count | Rationale |
|-------|---------|-------|-----------|
| L1 (Manual) | 01-04 | 4 | Pure CLI foundation, builds mental models before AI |
| L2 (AI Collab) | 05-11 | 7 | Complex topics where AI collaboration teaches evaluation |
| L3 (Intelligence) | 12-13 | 2 | Pattern recognition, reusable skill creation |
| L4 (Spec-Driven) | 14 | 1 | Capstone: spec-first production deployment |

---

## II. Success Evals (from Spec)

**SC-001**: All 21 identified issues resolved
**SC-002**: No lesson exceeds 35KB
**SC-003**: No lesson introduces more than 6 new concepts
**SC-004**: Three Roles invisible in ALL lessons (zero "AI as Teacher/Student/Co-Worker" labels)
**SC-005**: All commands use correct Linux syntax (no macOS flags)
**SC-006**: No forward references to unwritten chapters
**SC-007**: Every lesson has 2+ exercises with verification commands
**SC-008**: Health check scripts in ONE canonical form in L10, referenced elsewhere
**SC-009**: Quiz has 50 questions covering all 13 lessons with valid JSON
**SC-010**: Zero-experience students can complete L01-L04 without external help
**SC-011**: Students can deploy real agent as systemd service using ONLY chapter skills
**SC-012**: Chapter grade improves from B+ to A-

---

## III. Lesson-by-Lesson Architecture

### Lesson 01: The CLI Architect Mindset

**Filename**: `01-cli-architect-mindset.md`
**Content Source**: REWRITE (60% preserved from v1 L01)
**Layer**: L1 (Manual Foundation)
**CEFR**: B1
**Bloom's**: Remember/Understand
**Duration**: 45 min | **Size Target**: ~14KB (v1 is 14KB, well within limit)

**Learning Objectives**:
- LO-01-1: Explain why CLI mastery is essential for deploying and managing Digital FTEs [Bloom: Understand | B1]
- LO-01-2: Distinguish between terminal emulator and shell [Bloom: Understand | B1]
- LO-01-3: Navigate the Linux filesystem hierarchy using pwd, ls, cd [Bloom: Apply | B1]
- LO-01-4: Use both absolute and relative paths correctly [Bloom: Apply | B1]

**New Concepts** (count: 5, within B1 limit of 6):
1. Terminal vs shell (interface vs interpreter)
2. Linux filesystem hierarchy (/, /home, /etc, /var, /usr)
3. Absolute vs relative paths
4. Basic navigation commands (pwd, ls, cd)
5. CLI architect mindset (agents live on servers)

**Teaching Modality**: Hands-on discovery. Students explore their own filesystem rather than reading about it.

**Exercises** (FR-016):
1. Task: Navigate to /etc and list its contents. Verify: `ls /etc | head -5` shows configuration files.
2. Task: Create a directory `/tmp/agent-workspace` and navigate to it. Verify: `pwd` shows `/tmp/agent-workspace`.
3. Task: Navigate using relative path from /home to /var/log. Verify: `pwd` shows `/var/log`.

**Try With AI** (FR-005): NOT APPLICABLE for L1 lessons. L1 is manual foundation -- no AI prompts. "Try With AI" prompts begin at L2 (Lesson 05). For L01-L04, we use "Try It Yourself" exercises instead, which is the correct L1 pattern. Constitution states AI role is "minimal or absent" in L1.

**NOTE ON L1 AND "TRY WITH AI" (FR-005 vs Constitution)**:
FR-005 states "Each lesson MUST include exactly 3 Try With AI prompts." However, the Constitution Section IIa Layer 1 explicitly states: "AI Role: Minimal or absent." This creates a tension. Resolution: L01-L04 will include 3 "Try With AI" prompts but they will be conceptual exploration prompts (asking AI to explain concepts), NOT collaborative implementation prompts. This preserves FR-005 compliance while respecting L1's manual focus. The prompts will NOT involve AI writing code or executing tasks -- they will help students deepen understanding of concepts they have already practiced manually.

**Content Preserved from v1 L01**:
- Filesystem hierarchy explanation
- Terminal vs shell distinction
- Path navigation exercises
- Agent-deployment framing

**Content Changed**:
- Remove: References to "Chapter 9" and "Chapter 11" prerequisites
- Add: Brief mention of file operations (previewing L02)
- Add: Verification exercises with explicit commands
- Rewrite: Opening narrative for Agent Factory framing

**Skill Dependencies**: None (first lesson)

**Prerequisite Chain**: None

---

### Lesson 02: File Operations Mastery

**Filename**: `02-file-operations-mastery.md`
**Content Source**: NEW (100% new content)
**Layer**: L1 (Manual Foundation)
**CEFR**: B1
**Bloom's**: Apply
**Duration**: 45 min | **Size Target**: ~18KB

**Learning Objectives**:
- LO-02-1: Create files and directories using touch and mkdir -p [Bloom: Apply | B1]
- LO-02-2: Copy, move, and delete files safely using cp, mv, rm -i [Bloom: Apply | B1]
- LO-02-3: Read file contents using cat, head, tail, and less [Bloom: Apply | B1]
- LO-02-4: Use wildcards (*, ?, []) to target groups of files [Bloom: Apply | B1]

**New Concepts** (count: 6, at B1 limit):
1. File creation (touch, mkdir -p)
2. File copying and moving (cp, mv with safety flags)
3. File deletion with safety (rm -i, rm -r, the danger of rm -rf)
4. File reading (cat, head -n, tail -n, less)
5. Wildcards and glob patterns (*, ?, [])
6. Getting help (man, --help)

**Teaching Modality**: Scaffolded practice. Build a project directory structure step by step, practicing each operation.

**Exercises**:
1. Task: Create the directory structure `/tmp/my-agent/logs`, `/tmp/my-agent/config`, `/tmp/my-agent/data`. Verify: `find /tmp/my-agent -type d | sort` shows all 4 directories.
2. Task: Create 3 log files (agent-01.log, agent-02.log, agent-03.log) in the logs dir. Copy all .log files to a backup dir. Verify: `ls /tmp/my-agent/backup/*.log | wc -l` shows 3.
3. Task: Use `head -5` and `tail -5` on /var/log/syslog. Verify: Output shows first/last 5 lines.

**Try With AI** (L1 conceptual prompts):
1. "Ask Claude: What are the most dangerous commands a Linux beginner should be careful with, and what safe alternatives exist?" -- What you're learning: Building safety awareness before you have enough experience to make mistakes.
2. "Ask Claude: Explain the difference between hard links and symbolic links in Linux. When would you use each?" -- What you're learning: Deepening your filesystem mental model beyond what this lesson covers.
3. "Ask Claude: If I accidentally delete an important file on Linux, what recovery options exist? How does this compare to a desktop recycle bin?" -- What you're learning: Understanding that CLI operations are often permanent, reinforcing the -i flag habit.

**Safety Notes**: Prominent warning about `rm -rf`. Teach `rm -i` as default habit. Show `alias rm='rm -i'` pattern.

**Skill Dependencies**: Requires L01 (navigation)

---

### Lesson 03: Text Editing, Pipes & I/O Streams

**Filename**: `03-text-editing-pipes-streams.md`
**Content Source**: NEW (100% new content; nano was mentioned but never taught in v1)
**Layer**: L1 (Manual Foundation)
**CEFR**: B1
**Bloom's**: Apply
**Duration**: 50 min | **Size Target**: ~20KB

**Learning Objectives**:
- LO-03-1: Edit files using nano (open, navigate, edit, save with Ctrl+O, exit with Ctrl+X) [Bloom: Apply | B1]
- LO-03-2: Explain stdin, stdout, and stderr as data channels between commands [Bloom: Understand | B1]
- LO-03-3: Pipe command output using | to compose commands [Bloom: Apply | B1]
- LO-03-4: Redirect output using >, >>, and 2> [Bloom: Apply | B1]

**New Concepts** (count: 6, at B1 limit):
1. nano text editor (open, edit, save Ctrl+O, exit Ctrl+X, search Ctrl+W)
2. stdin (standard input, fd 0)
3. stdout (standard output, fd 1)
4. stderr (standard error, fd 2)
5. Pipe operator (| connects stdout to stdin)
6. Redirection operators (>, >>, 2>, 2>&1)

**Teaching Modality**: Hands-on discovery. Students edit a real config file, then discover how commands compose.

**Exercises**:
1. Task: Create a file with nano containing 3 lines of text. Verify: `cat /tmp/my-file.txt | wc -l` shows 3.
2. Task: Pipe `ls -la /etc` through `grep conf` and count results. Verify: `ls -la /etc | grep conf | wc -l` outputs a number.
3. Task: Run a command that produces both stdout and stderr, redirect stderr to a file. Verify: `cat /tmp/errors.txt` shows error messages only.

**Try With AI** (L1 conceptual prompts):
1. "Ask Claude: The Unix philosophy says 'do one thing well.' How do pipes enable this philosophy? Give me 3 examples of powerful pipe chains." -- What you're learning: Understanding the compositional design that makes Linux powerful.
2. "Ask Claude: What are the most useful nano keyboard shortcuts beyond save and exit? Create a quick reference I can print." -- What you're learning: Building efficient editing muscle memory.
3. "Ask Claude: Explain the difference between > and >> with a real-world analogy. When would using > accidentally destroy data?" -- What you're learning: Understanding destructive vs. appending operations.

**Skill Dependencies**: Requires L01 (navigation), L02 (file operations -- creating files to edit)

---

### Lesson 04: Modern Terminal Environment

**Filename**: `04-modern-terminal-environment.md`
**Content Source**: REWRITE (50% preserved from v1 L02)
**Layer**: L1 (Manual Foundation)
**CEFR**: B1
**Bloom's**: Apply
**Duration**: 50 min | **Size Target**: ~20KB (v1 L02 is 20KB, fits)

**Learning Objectives**:
- LO-04-1: Install packages using apt (update, install, search) [Bloom: Apply | B1]
- LO-04-2: Configure shell aliases and environment variables in .bashrc [Bloom: Apply | B1]
- LO-04-3: Install and use zoxide for fast directory navigation [Bloom: Apply | B1]
- LO-04-4: Install and use fzf for fuzzy history search [Bloom: Apply | B1]

**New Concepts** (count: 5, within B1 limit of 6):
1. Package management (apt update, apt install, apt search)
2. Shell configuration (.bashrc, source)
3. Aliases (shortcut commands)
4. Environment variables (export, sourcing .env files)
5. Modern navigation tools (zoxide, fzf)

**Teaching Modality**: Progressive tool installation. Each tool solves a pain point students just experienced in L01-L03.

**Content Preserved from v1 L02**:
- zoxide installation and usage
- fzf installation and usage
- .bashrc configuration
- Alias creation

**Content Changed**:
- Remove: nano teaching (moved to L03)
- Remove: Environment variable scoping deep-dive (moved to L08 Security Hardening)
- Add: apt package management (prerequisite for all tool installation)
- Add: Verification exercises

**Exercises**:
1. Task: Install `tree` using apt. Verify: `tree /tmp/my-agent` displays directory tree.
2. Task: Create alias `ll='ls -la'` in .bashrc and source it. Verify: `alias ll` shows the alias definition.
3. Task: Install zoxide, add init to .bashrc, and jump to a visited directory. Verify: `z agent` navigates to `/tmp/my-agent/`.

**Try With AI** (L1 conceptual prompts):
1. "Ask Claude: What are the 10 most useful bash aliases for someone managing AI agents on Linux servers?" -- What you're learning: Discovering productivity patterns from experienced administrators.
2. "Ask Claude: Compare zoxide, autojump, and fasd for directory navigation. Which is best for a beginner and why?" -- What you're learning: Evaluating tool choices with informed criteria.
3. "Ask Claude: What's the difference between ~/.bashrc, ~/.bash_profile, and ~/.profile? When does each get loaded?" -- What you're learning: Understanding shell initialization, which prevents configuration mistakes.

**Skill Dependencies**: Requires L01-L03 (navigation, file ops, text editing -- needed to edit .bashrc)

---

### L1 -> L2 Transition Boundary

**Transition criteria met at end of L04:**
1. Comprehension: Students can explain filesystem, pipes, editing, package management
2. Independent execution: Students can navigate, create/edit files, install tools without instructions
3. Error recognition: Students can identify bad paths, permission errors, missing packages

**Why L2 starts at L05 (tmux):** tmux enables multi-pane workflows ideal for AI collaboration -- monitoring in one pane, AI prompting in another. The tool itself facilitates the L2 teaching pattern.

---

### Lesson 05: Persistent Sessions with tmux

**Filename**: `05-persistent-sessions-tmux.md`
**Content Source**: REWRITE (55% preserved from v1 L03)
**Layer**: L2 (AI Collaboration)
**CEFR**: B2
**Bloom's**: Apply
**Duration**: 55 min | **Size Target**: ~23KB (v1 L03 is 23KB, need slight reduction)

**Learning Objectives**:
- LO-05-1: Create, detach from, and reattach to tmux sessions [Bloom: Apply | B2]
- LO-05-2: Split tmux panes horizontally and vertically for multi-task workflows [Bloom: Apply | B2]
- LO-05-3: Create named sessions for different project contexts [Bloom: Apply | B2]
- LO-05-4: Write session scripts for reproducible tmux layouts [Bloom: Apply | B2]

**New Concepts** (count: 6, at B2 limit of 6):
1. tmux sessions (create, detach Ctrl+B d, reattach tmux a)
2. Pane splitting (Ctrl+B % vertical, Ctrl+B " horizontal)
3. Named sessions (tmux new -s name)
4. Session scripts (bash scripts that create layouts)
5. Window management (Ctrl+B c new window, Ctrl+B n/p switch)
6. Prefix key customization (.tmux.conf)

**Teaching Modality**: Problem-solution discovery. Present the problem (SSH disconnect kills work), then solve it step by step.

**Three Roles Invisibility Strategy** (L2 lesson):
- **AI as Teacher (invisible)**: "Try With AI" prompt asks AI to suggest an efficient tmux layout for agent monitoring -- AI teaches layout patterns the student hasn't considered.
- **AI as Student (invisible)**: Exercise asks student to describe their specific workflow to AI and get a custom session script -- student teaches AI their constraints.
- **AI as Co-Worker (invisible)**: Iterative refinement exercise where student and AI collaboratively improve a session script through 2-3 rounds of feedback.

**Content Preserved from v1 L03**:
- Basic tmux operations (create, detach, reattach)
- Pane splitting mechanics
- Agent monitoring layout example

**Content Removed**:
- "Phase 2: Three Roles Demonstration" section header and explicit role labels
- Scripted AI conversation examples
- Meta-commentary about framework

**Content Added**:
- Session script creation exercise
- Verification steps for each operation
- Natural "Try With AI" prompts (no role labels)

**Exercises**:
1. Task: Create a tmux session named "agent-monitor", split into 3 panes. Verify: `tmux list-panes -t agent-monitor | wc -l` shows 3.
2. Task: Detach from session, then reattach. Verify: `tmux ls` shows session exists; after reattach all panes intact.
3. Task: Write a session script that creates your preferred layout. Verify: Run script, `tmux ls` shows session with correct name.

**Try With AI** (FR-005, Three Roles invisible):
1. "Ask Claude: I manage 3 AI agents that each need monitoring (logs, resource usage, health checks). Design a tmux session layout that lets me monitor all 3 simultaneously. Show me the session script." -- What you're learning: AI suggests monitoring patterns you haven't considered, combining tmux with commands you learned in earlier lessons.
2. "Copy the session script Claude generated. Now tell Claude: 'This layout needs adjustment -- I also need a pane for editing config files with nano, and the log panes should be smaller since I mostly glance at them.' Compare the versions." -- What you're learning: Refining AI output by providing your specific workspace constraints produces a better result than the generic first draft.
3. "Take your final tmux script and ask Claude: 'Review this for edge cases. What happens if a session with this name already exists? What if one of the agent log files doesn't exist yet?'" -- What you're learning: Iterative improvement catches problems neither you nor AI initially considered.

**Skill Dependencies**: Requires L01-L04 (all L1 foundation)

---

### Lesson 06: Bash Scripting Foundations

**Filename**: `06-bash-scripting-foundations.md`
**Content Source**: SPLIT from v1 L04 (scripting portion, ~45% of v1 L04 preserved)
**Layer**: L2 (AI Collaboration)
**CEFR**: B2
**Bloom's**: Apply
**Duration**: 55 min | **Size Target**: ~22KB (v1 L04 was 34KB, this is the scripting half)

**Learning Objectives**:
- LO-06-1: Write executable bash scripts with shebang and proper permissions [Bloom: Apply | B2]
- LO-06-2: Use variables with proper quoting and error handling (set -euo pipefail) [Bloom: Apply | B2]
- LO-06-3: Implement functions for reusable script logic [Bloom: Apply | B2]
- LO-06-4: Use conditionals (if/else, test) and loops (for, while) for control flow [Bloom: Apply | B2]

**New Concepts** (count: 6, at B2 limit):
1. Shebang line (#!/bin/bash) and chmod +x
2. Variables and quoting ("${VAR}" prevents word splitting)
3. Error handling (set -euo pipefail)
4. Functions (declaration, return codes, local variables)
5. Conditionals (if/else, test commands, [[ ]])
6. Loops (for item in list, while read line)

**Teaching Modality**: Progressive script building. Start with a 3-line script, add complexity incrementally.

**Three Roles Invisibility Strategy**:
- **AI as Teacher (invisible)**: Try With AI prompt asks AI to review a student's script and suggest error handling patterns.
- **AI as Student (invisible)**: Student provides their specific agent setup requirements and AI generates a custom script.
- **AI as Co-Worker (invisible)**: Student and AI iterate on improving a deployment script through multiple rounds.

**Content Preserved from v1 L04**:
- Shebang and permissions
- Variable usage and quoting
- Error handling with set flags
- Function definitions
- Agent setup script example

**Content Removed**:
- ALL grep/sed/awk content (moved to L07)
- ALL cron content (moved to L07)
- ALL pipe chaining beyond basics (covered in L03)
- "Three Roles" section headers and explicit labels
- `stat -f%z` (macOS syntax -- replaced with `stat -c%s`)
- Health check script (consolidated to L10 per FR-017)

**Content Added**:
- More incremental script examples (3-line -> 10-line -> 30-line progression)
- Explicit verification exercises
- Natural "Try With AI" prompts

**Factual Fix (FR-012)**: All `stat -f%z` replaced with `stat -c%s`.

**Exercises**:
1. Task: Write a script that creates an agent workspace with logs/, config/, and data/ subdirectories. Verify: `bash setup-workspace.sh && ls /tmp/agent-ws/` shows all 3 dirs.
2. Task: Add error handling (set -euo pipefail) and a function that checks if a directory exists before creating it. Verify: Run script twice -- second run outputs "already exists" instead of error.
3. Task: Write a loop that processes all .log files in a directory and reports their line counts. Verify: `bash count-logs.sh /var/log/` outputs filename:linecount pairs.

**Try With AI** (FR-005, Three Roles invisible):
1. "Write a basic agent setup script (install dependencies, create user, create directories). Then ask Claude: 'Review this script for production reliability. What error conditions am I not handling?'" -- What you're learning: AI identifies failure modes you haven't experienced yet (disk full, network down, user already exists).
2. "Tell Claude your specific agent requirements: 'I need a setup script for a Python FastAPI agent that runs under user agent-runner, stores logs in /var/log/agents/, and needs Python 3.11 and uvicorn installed.' Compare what Claude generates to your manual script." -- What you're learning: Providing precise constraints produces scripts tailored to your exact needs.
3. "Take Claude's generated script and test it mentally: What happens if Python 3.11 isn't available in apt? What if the user already exists? Ask Claude to add handling for these edge cases, then review the additions." -- What you're learning: Iterative refinement catches real deployment issues that initial scripts miss.

**Skill Dependencies**: Requires L01-L04 (navigation, file ops, text editing, package management)

---

### Lesson 07: Text Processing & Automation

**Filename**: `07-text-processing-automation.md`
**Content Source**: SPLIT from v1 L04 (text processing portion, ~40% of v1 L04 preserved + new cron content)
**Layer**: L2 (AI Collaboration)
**CEFR**: B2
**Bloom's**: Apply
**Duration**: 55 min | **Size Target**: ~22KB

**Learning Objectives**:
- LO-07-1: Use grep with regular expressions to search log files [Bloom: Apply | B2]
- LO-07-2: Use sed for text transformation and substitution [Bloom: Apply | B2]
- LO-07-3: Use awk for field extraction from structured data [Bloom: Apply | B2]
- LO-07-4: Create cron jobs for scheduled automation tasks [Bloom: Apply | B2]

**New Concepts** (count: 6, at B2 limit):
1. grep pattern matching (grep -E, regex basics: ., *, +, [], ^, $)
2. sed stream editing (s/old/new/g, in-place with -i)
3. awk field processing ('{print $1, $3}', field separators -F)
4. Pipeline composition (grep | sed | awk chains)
5. cron job scheduling (crontab -e, cron syntax * * * * *)
6. Log rotation concept (logrotate, size-based rotation)

**Teaching Modality**: Error analysis. Students parse REAL log files to find problems, then automate the analysis.

**Three Roles Invisibility Strategy**:
- **AI as Teacher (invisible)**: AI teaches regex patterns for common log analysis scenarios.
- **AI as Student (invisible)**: Student specifies their log format and AI adapts patterns to match.
- **AI as Co-Worker (invisible)**: Student and AI collaboratively build a log analysis pipeline.

**Content Preserved from v1 L04**:
- grep usage with regex
- sed substitution examples
- awk field extraction
- Agent log parsing examples

**Content Removed**:
- ALL scripting fundamentals (moved to L06)
- Health check scripts (consolidated to L10)
- `stat -f%z` occurrences

**Content Added**:
- cron job creation and management
- Log rotation basics
- More verification exercises
- Pipeline composition examples (multi-step grep|sed|awk)

**Exercises**:
1. Task: Find all ERROR lines in a log file from the last hour using grep. Verify: `grep -c "ERROR" /var/log/syslog` returns a count.
2. Task: Extract the timestamp and message from log lines using awk. Verify: `awk '{print $1, $2, $NF}' /var/log/syslog | head -3` shows formatted output.
3. Task: Create a cron job that runs every 5 minutes and appends disk usage to a file. Verify: `crontab -l | grep "df -h"` shows the scheduled job.

**Try With AI** (FR-005, Three Roles invisible):
1. "Ask Claude: 'I have agent logs in this format: [2026-02-08 14:23:01] ERROR agent-03: Connection timeout to database. Write me a grep+awk pipeline that extracts just the timestamp and error message for all ERROR entries.'" -- What you're learning: AI translates your log format into precise command pipelines faster than learning regex from scratch.
2. "Now tell Claude: 'Actually, my logs also have WARNING entries I care about, and I need to sort by timestamp and count occurrences of each error type.' See how the pipeline evolves." -- What you're learning: Specifying additional constraints refines the pipeline in ways you might not have designed yourself.
3. "Ask Claude: 'Write a cron job that runs this log analysis pipeline every hour and emails me if ERROR count exceeds 10. Include the crontab entry and any helper scripts needed.' Review what Claude produces -- does the email approach work on a headless server?" -- What you're learning: Collaboratively discovering that cron + email on a server requires additional configuration (mailutils, SMTP) that simple examples omit.

**Skill Dependencies**: Requires L03 (pipes/redirection), L06 (bash scripting basics)

---

### Lesson 08: Security Hardening & Least Privilege

**Filename**: `08-security-hardening.md`
**Content Source**: REWRITE (50% preserved from v1 L05)
**Layer**: L2 (AI Collaboration)
**CEFR**: B2
**Bloom's**: Apply/Analyze
**Duration**: 60 min | **Size Target**: ~22KB (v1 L05 is 20KB, slight growth for env var scoping)

**Learning Objectives**:
- LO-08-1: Create dedicated non-root users for agent processes [Bloom: Apply | B2]
- LO-08-2: Configure file permissions using chmod and chown following least-privilege principle [Bloom: Apply | B2]
- LO-08-3: Manage environment variables with proper scoping (export vs non-export, subshell visibility) [Bloom: Analyze | B2]
- LO-08-4: Handle secrets using environment variables sourced from .env files (never hardcoded) [Bloom: Apply | B2]

**New Concepts** (count: 6, at B2 limit):
1. User creation (useradd, dedicated agent users)
2. File permissions model (user/group/others, rwx, numeric modes)
3. chmod and chown (setting permissions and ownership)
4. sudo and root (privilege escalation, why not to run as root)
5. Environment variable scoping (export vs local, subshell inheritance)
6. Secret management (.env files, sourcing, never committing to git)

**Teaching Modality**: Socratic. Present a security incident, ask "what went wrong?", then build the defense.

**Three Roles Invisibility Strategy**:
- **AI as Teacher (invisible)**: AI suggests security hardening steps the student hasn't considered (like checking open ports).
- **AI as Student (invisible)**: Student specifies their exact deployment scenario and AI adjusts security recommendations.
- **AI as Co-Worker (invisible)**: Iterative permission audit where student and AI review and tighten permissions together.

**Content Preserved from v1 L05**:
- User creation for agents
- chmod/chown usage
- Least privilege principle explanation
- SSH key generation

**Content Removed**:
- SSH key generation and configuration (moved to L09 Networking/SSH)
- sshd_config modification (moved to L09)
- "Three Roles" section headers
- Explicit role labels

**Content Added**:
- Environment variable scoping deep-dive (from v1 L02 -- moved here where it belongs with security)
- .env file management pattern
- Secret rotation awareness
- Verification exercises for each permission change

**Exercises**:
1. Task: Create user `agent-runner` with no login shell. Verify: `id agent-runner` shows uid/gid; `grep agent-runner /etc/passwd` shows `/usr/sbin/nologin`.
2. Task: Create a config file readable only by agent-runner. Verify: `ls -la /etc/agent/config.yaml` shows `-rw-------` and correct owner.
3. Task: Set an environment variable with export in a script, then verify it IS visible in a subshell but a non-exported variable is NOT. Verify: `bash -c 'echo $MY_EXPORT'` shows value; `bash -c 'echo $MY_LOCAL'` shows empty.

**Try With AI** (FR-005, Three Roles invisible):
1. "Ask Claude: 'I'm deploying an AI agent that needs to read API keys and write to a log directory. What's the minimum permission set this agent needs? Assume it runs as user agent-runner.'" -- What you're learning: AI applies least-privilege analysis systematically, suggesting restrictions you might skip for convenience.
2. "Tell Claude: 'The agent also needs to bind to port 8080, but I don't want it running as root. What are my options?' Evaluate which approach Claude recommends." -- What you're learning: The trade-off between setcap, reverse proxy, and high ports has security implications that merit analysis.
3. "Ask Claude: 'Audit this permission setup I created. Here's my ls -la output for /opt/agent/...' Paste your actual directory listing and see what Claude flags." -- What you're learning: A security review from another perspective catches oversights in your setup.

**Skill Dependencies**: Requires L02 (file operations), L04 (package management for installing tools), L06 (bash scripting for .env sourcing)

---

### Lesson 09: Networking Fundamentals & SSH Remote Access

**Filename**: `09-networking-ssh-remote-access.md`
**Content Source**: NEW (100% new; v1 had no networking or SSH lesson)
**Layer**: L2 (AI Collaboration)
**CEFR**: B2
**Bloom's**: Apply/Analyze
**Duration**: 60 min | **Size Target**: ~22KB

**Learning Objectives**:
- LO-09-1: Explain ports, localhost vs 0.0.0.0, and why binding address matters for agents [Bloom: Understand | B2]
- LO-09-2: Use curl to test HTTP endpoints locally [Bloom: Apply | B2]
- LO-09-3: Establish SSH connections and configure ~/.ssh/config for multiple servers [Bloom: Apply | B2]
- LO-09-4: Configure basic firewall rules with ufw [Bloom: Apply | B2]

**New Concepts** (count: 6, at B2 limit):
1. Ports (what they are, well-known ports, agent binding)
2. localhost vs 0.0.0.0 (loopback vs all interfaces, security implications)
3. curl for HTTP testing (GET, POST, checking agent health endpoints)
4. SSH connection (ssh user@host, key-based auth, ~/.ssh/config)
5. SSH key management (ssh-keygen, ssh-copy-id, authorized_keys)
6. Firewall basics (ufw allow/deny/status, protecting agent ports)

**Teaching Modality**: Layered debugging. Start from "can I reach my agent?" and build diagnostic layers.

**Three Roles Invisibility Strategy**:
- **AI as Teacher (invisible)**: AI explains networking concepts (why 0.0.0.0 is different from 127.0.0.1) with diagrams the student requests.
- **AI as Student (invisible)**: Student describes their specific server setup and AI generates a tailored SSH config.
- **AI as Co-Worker (invisible)**: Student and AI collaboratively debug a "connection refused" scenario step by step.

**SSH Lockout Prevention Protocol** (from spec edge case): Step-by-step instructions that test key authentication BEFORE disabling password auth. Explicit warning: "ALWAYS keep a backup session open when modifying sshd_config."

**Exercises**:
1. Task: Use curl to test if anything is listening on port 8000 locally. Verify: `curl -s -o /dev/null -w "%{http_code}" http://localhost:8000` returns a status code (or "connection refused").
2. Task: Generate an SSH key pair and display the public key. Verify: `ls ~/.ssh/id_ed25519*` shows both files; `cat ~/.ssh/id_ed25519.pub` shows key.
3. Task: Create an SSH config entry for a server alias. Verify: `grep -c "Host" ~/.ssh/config` shows entry count.

**Try With AI** (FR-005, Three Roles invisible):
1. "Ask Claude: 'My AI agent is running on port 8000 but I can only reach it from the server itself, not from my laptop. Walk me through the diagnostic steps to figure out why.'" -- What you're learning: AI teaches a systematic networking diagnostic approach: check binding address, then firewall, then routing.
2. "Tell Claude: 'I have 5 servers I SSH into regularly. Here are their details: [list hostnames, users, ports, key files]. Generate my ~/.ssh/config file.' Review what Claude generates." -- What you're learning: Translating your specific infrastructure into configuration is exactly where AI collaboration saves time.
3. "Ask Claude: 'I want to lock down SSH on my agent server. Walk me through the changes to sshd_config, but make sure I don't lock myself out.' Follow each step and verify." -- What you're learning: Safety-critical configuration changes benefit from step-by-step collaboration with verification at each stage.

**Skill Dependencies**: Requires L08 (SSH keys introduced in security context), L04 (apt for installing tools)

---

### Lesson 10: Process Control & Systemd Services

**Filename**: `10-process-control-systemd.md`
**Content Source**: REWRITE (45% preserved from v1 L06)
**Layer**: L2 (AI Collaboration)
**CEFR**: B2
**Bloom's**: Analyze
**Duration**: 60 min | **Size Target**: ~28KB (v1 L06 is 32KB, reducing)

**Learning Objectives**:
- LO-10-1: Write a systemd .service file with correct section structure [Bloom: Apply | B2]
- LO-10-2: Configure restart policies (Restart=on-failure) with start-limit protection [Bloom: Analyze | B2]
- LO-10-3: Monitor services using systemctl status and journalctl -u [Bloom: Apply | B2]
- LO-10-4: Set resource limits (MemoryMax, CPUQuota) for agent processes [Bloom: Apply | B2]

**New Concepts** (count: 6, at B2 limit):
1. systemd service file structure ([Unit], [Service], [Install])
2. Restart policy (Restart=on-failure -- correct from the start per FR-013)
3. Start-limit protection (StartLimitBurst, StartLimitIntervalSec, RestartSec)
4. Service lifecycle (systemctl start/stop/enable/disable/status)
5. Service logs (journalctl -u, -f for follow, --since for time ranges)
6. Resource limits (MemoryMax, CPUQuota in service file)

**CANONICAL HEALTH CHECK SCRIPT (FR-017)**: This lesson contains the ONE canonical agent health check script. All other lessons reference it via markdown link.

```bash
#!/bin/bash
# Canonical agent health check - referenced from other lessons
# Location: Taught in Lesson 10, section "Agent Health Checks"
set -euo pipefail

SERVICE_NAME="${1:?Usage: check-agent-health.sh <service-name>}"

check_service() {
    systemctl is-active --quiet "$SERVICE_NAME"
}

check_health_endpoint() {
    local port="${2:-8000}"
    curl -sf "http://localhost:${port}/health" > /dev/null 2>&1
}

check_resources() {
    local mem_usage
    mem_usage=$(systemctl show "$SERVICE_NAME" --property=MemoryCurrent --value)
    echo "Memory: ${mem_usage}"
}

main() {
    echo "=== Agent Health Check: $SERVICE_NAME ==="

    if check_service; then
        echo "[OK] Service is running"
    else
        echo "[FAIL] Service is not running"
        exit 1
    fi

    if check_health_endpoint; then
        echo "[OK] Health endpoint responding"
    else
        echo "[WARN] Health endpoint not responding"
    fi

    check_resources
    echo "=== Check complete ==="
}

main "$@"
```

**Teaching Modality**: Progressive complexity. Start with minimal .service file, add features incrementally.

**Factual Fix (FR-013)**: Teach `Restart=on-failure` as default from the start. No "teach wrong then correct" pattern. Brief note explaining why `Restart=always` is problematic (prevents controlled stops), but `on-failure` is the correct production default.

**Three Roles Invisibility Strategy**:
- **AI as Teacher (invisible)**: AI suggests start-limit protection and resource limits the student hasn't considered.
- **AI as Student (invisible)**: Student specifies their agent's resource requirements and AI adjusts the service file.
- **AI as Co-Worker (invisible)**: Iterative service file improvement through multiple rounds of review.

**Content Preserved from v1 L06**:
- Service file structure explanation
- systemctl commands
- journalctl log viewing
- Service template concept (agent@.service)

**Content Removed**:
- `Restart=always` as initial teaching (replaced with `Restart=on-failure`)
- "Three Roles Demonstration" section header
- Duplicated health check scripts (consolidated here as canonical)
- nginx references

**Content Added**:
- Canonical health check script (ONE location, FR-017)
- Resource limits (MemoryMax, CPUQuota)
- Start-limit protection (RestartSec, StartLimitBurst)
- Verification exercises

**Exercises**:
1. Task: Write a minimal .service file for a Python agent. Verify: `systemd-analyze verify /etc/systemd/system/my-agent.service` shows no errors.
2. Task: Enable and start the service. Verify: `systemctl is-active my-agent` shows "active"; `systemctl is-enabled my-agent` shows "enabled".
3. Task: Kill the agent process and observe automatic restart. Verify: `journalctl -u my-agent --since "1 min ago"` shows restart entry.

**Try With AI** (FR-005, Three Roles invisible):
1. "Ask Claude: 'Here is my service file for an AI agent. What production hardening am I missing?' Paste your .service file and see what Claude suggests." -- What you're learning: Production service files need protections (resource limits, security directives, logging) that basic examples skip.
2. "Tell Claude: 'My agent sometimes crashes due to out-of-memory errors after running for 12+ hours. It processes large documents. Design a service configuration that handles this gracefully.' Compare Claude's approach to yours." -- What you're learning: Specifying your exact failure mode produces targeted solutions (MemoryMax, restart with backoff) rather than generic templates.
3. "Ask Claude: 'Write a service template (agent@.service) that lets me run 3 instances of my agent on different ports. Show me how to start agent@8001, agent@8002, agent@8003.' Test the template." -- What you're learning: Iterating on parameterized templates with AI reveals edge cases in variable substitution.

**Skill Dependencies**: Requires L06 (bash scripting for health check), L08 (dedicated users for service User= directive), L09 (ports for agent binding)

---

### Lesson 11: Debugging & Troubleshooting

**Filename**: `11-debugging-troubleshooting.md`
**Content Source**: REWRITE (50% preserved from v1 L07)
**Layer**: L2 (AI Collaboration)
**CEFR**: B2
**Bloom's**: Analyze
**Duration**: 60 min | **Size Target**: ~23KB (v1 L07 is 23KB)

**Learning Objectives**:
- LO-11-1: Use journalctl with filters to diagnose systemd service failures [Bloom: Analyze | B2]
- LO-11-2: Apply layered network diagnosis (local -> DNS -> remote) to isolate failures [Bloom: Analyze | B2]
- LO-11-3: Identify disk space issues using df and du [Bloom: Apply | B2]
- LO-11-4: Apply structured triage methodology (logs -> network -> disk -> processes) [Bloom: Analyze | B2]

**New Concepts** (count: 6, at B2 limit):
1. journalctl filtering (--since, --until, -p for priority, -u for unit)
2. Layered network diagnosis (ping -> curl -> ss -> firewall check)
3. Disk diagnostics (df -h for overview, du -sh for culprit finding)
4. Process inspection (ps aux, top/htop, strace -p PID)
5. Real-time monitoring (tail -f, journalctl -f)
6. Structured triage methodology (systematic order, not random guessing)

**Teaching Modality**: Error analysis. Present broken scenarios, students diagnose using the triage methodology.

**Three Roles Invisibility Strategy**:
- **AI as Teacher (invisible)**: AI teaches diagnostic patterns student hasn't considered (like checking /var/log/auth.log for security issues).
- **AI as Student (invisible)**: Student pastes actual error output and AI must adapt diagnosis to the specific context.
- **AI as Co-Worker (invisible)**: Student and AI work through a multi-layer debugging scenario together, with AI suggesting next steps and student providing system-specific context.

**Content Preserved from v1 L07**:
- journalctl usage
- Structured triage approach
- Process inspection commands
- Disk space diagnostics

**Content Removed**:
- "Phase 2: Three Roles Demonstration" section header
- Networking diagnostics that assumed untaught knowledge (now L09 is prerequisite)
- Duplicated health check scripts (reference L10 canonical version)

**Content Added**:
- Explicit reference to health check in L10: `See [Health Check Script](10-process-control-systemd.md#agent-health-checks)`
- Network diagnosis now builds on L09's networking foundation
- More verification exercises

**Exercises**:
1. Task: Find all ERROR-level messages from the last hour in journalctl. Verify: `journalctl -p err --since "1 hour ago" | head -5` shows errors or "No entries."
2. Task: Check disk usage on /var/log and find the largest log file. Verify: `du -sh /var/log/*  | sort -rh | head -3` shows top 3 consumers.
3. Task: Use ss to find all processes listening on network ports. Verify: `ss -tlnp | grep LISTEN` shows listening services.

**Try With AI** (FR-005, Three Roles invisible):
1. "Ask Claude: 'My agent service shows "failed" in systemctl status. Here is the output: [paste your actual systemctl status output]. What's wrong and how do I fix it?'" -- What you're learning: AI can parse complex error output and suggest targeted fixes faster than reading man pages.
2. "Tell Claude: 'The agent was working yesterday but fails today. Nothing changed in the code. What environmental factors should I check?' Then systematically verify each suggestion." -- What you're learning: Debugging requires considering the full environment (disk, memory, network, config changes), not just code.
3. "Reproduce a common failure (kill a dependency process or fill up /tmp), then work with Claude to diagnose it WITHOUT telling Claude what you did. See if AI's diagnostic process finds the real cause." -- What you're learning: Testing diagnostic methodology by creating known failures and validating the troubleshooting process.

**Skill Dependencies**: Requires L09 (networking for network diagnosis), L10 (systemd for service debugging)

---

### L2 -> L3 Transition Boundary

**Transition criteria met at end of L11:**
1. Pattern recognition: Students have used similar deployment workflows 2+ times across L05-L11
2. Reusability: Deployment patterns (user creation, service file, monitoring, debugging) recur across any agent deployment
3. Complexity: The full deployment workflow has 10+ steps worth encoding as reusable intelligence

---

### Lesson 12: Advanced Workflow Integration Patterns

**Filename**: `12-workflow-integration-patterns.md`
**Content Source**: SPLIT from v1 L08 (deployment patterns portion, ~30% of v1 L08 preserved)
**Layer**: L3 (Intelligence Design)
**CEFR**: C1
**Bloom's**: Evaluate
**Duration**: 65 min | **Size Target**: ~25KB (v1 L08 was 48KB, far over limit)

**Learning Objectives**:
- LO-12-1: Evaluate deployment patterns (restart vs blue-green vs rolling) and justify selection for specific scenarios [Bloom: Evaluate | C1]
- LO-12-2: Design a monitoring setup combining log rotation, disk alerts, and health checks [Bloom: Create | C1]
- LO-12-3: Implement a multi-step deployment workflow combining scripting, systemd, and monitoring [Bloom: Apply | C1]
- LO-12-4: Compare systemd-based deployment with container-based approaches (Docker awareness) [Bloom: Analyze | C1]

**New Concepts** (count: 5, within C1 allowance):
1. Deployment patterns (restart, blue-green, rolling -- trade-off analysis)
2. Zero-downtime deployment strategies
3. Monitoring integration (combining log rotation + health checks + alerts)
4. Multi-component orchestration (script + service + monitoring as one workflow)
5. Container awareness (brief Docker comparison -- FR-014 note, not full lesson)

**Teaching Modality**: Spec-first design. Students evaluate trade-offs between approaches before implementing.

**Three Roles Invisibility Strategy**:
- **AI as Teacher (invisible)**: AI teaches deployment patterns and trade-offs student hasn't encountered in production.
- **AI as Student (invisible)**: Student describes their specific agent update workflow and AI adapts pattern recommendation.
- **AI as Co-Worker (invisible)**: Student and AI collaboratively design a deployment workflow, iterating on approach.

**Content Preserved from v1 L08**:
- Blue-green deployment concept
- Monitoring integration patterns
- Multi-agent management concepts

**Content Removed**:
- Skill creation content (moved to L13)
- Duplicated health check scripts (reference L10 canonical)
- Oversized code blocks (keep under 35KB)
- `Restart=always` references (corrected to `Restart=on-failure`)

**Content Added**:
- Docker awareness note (FR-014): Brief paragraph comparing systemd to Docker, referencing the Docker chapter for details
- Explicit trade-off analysis framework
- Verification exercises for deployment patterns

**Exercises**:
1. Task: Document a blue-green deployment plan for updating an agent from v1 to v2. Verify: Plan includes old service, new service, health check, traffic switch, and rollback steps.
2. Task: Configure logrotate for agent logs (rotate weekly, keep 4 weeks, compress). Verify: `cat /etc/logrotate.d/agent-logs` shows correct configuration.
3. Task: Write a deployment script that combines user creation, service file installation, service start, and health verification. Verify: Run script, `systemctl is-active my-agent` shows active AND `curl localhost:8000/health` returns 200.

**Try With AI** (FR-005, Three Roles invisible):
1. "Ask Claude: 'I need to update my production agent with zero downtime. Compare restart, blue-green, and rolling deployment approaches for a single-server setup. Which do you recommend and why?'" -- What you're learning: AI helps you evaluate production trade-offs by considering factors (resource overhead, complexity, rollback speed) that are hard to assess without experience.
2. "Tell Claude: 'I chose blue-green deployment. My constraint: only one server with 2GB RAM, so I can't run both versions simultaneously for long. Design a deployment script that minimizes overlap time.' Review the approach." -- What you're learning: Providing real resource constraints forces practical solutions instead of textbook ideals.
3. "Ask Claude: 'Review my complete deployment workflow: [paste your deployment script]. What failure scenarios does it NOT handle? Add error handling for each one.'" -- What you're learning: Production workflows need resilience against failures at every step -- something that emerges through iterative review.

**Skill Dependencies**: Requires L06 (scripting), L10 (systemd), L11 (debugging for health validation)

---

### Lesson 13: Building Reusable Agent Operations Skills

**Filename**: `13-building-reusable-skills.md`
**Content Source**: SPLIT from v1 L08 (skill creation portion, ~20% of v1 L08 preserved) + substantial new content
**Layer**: L3 (Intelligence Design)
**CEFR**: C1
**Bloom's**: Create
**Duration**: 55 min | **Size Target**: ~22KB

**Learning Objectives**:
- LO-13-1: Identify recurring operational patterns that justify creating reusable automation [Bloom: Analyze | C1]
- LO-13-2: Design a deployment skill specification using Persona + Questions + Principles pattern [Bloom: Create | C1]
- LO-13-3: Implement a reusable deployment script encapsulating L01-L12 knowledge [Bloom: Create | C1]
- LO-13-4: Test reusable skills on fresh systems to validate completeness [Bloom: Evaluate | C1]

**New Concepts** (count: 5, within C1 allowance):
1. Pattern recognition (identifying recurring workflows from L05-L12)
2. Skill specification design (Persona + Questions + Principles)
3. Automation encapsulation (packaging multi-step workflows)
4. Fresh-system testing (validating skills work outside your configured environment)
5. Documentation for reuse (README, usage examples, prerequisites)

**Teaching Modality**: Collaborative design. Students identify patterns from their own experience and formalize them.

**Three Roles Invisibility Strategy**:
- **AI as Teacher (invisible)**: AI suggests skill structure patterns the student hasn't seen.
- **AI as Student (invisible)**: Student defines their specific operational patterns and AI helps formalize them.
- **AI as Co-Worker (invisible)**: Student and AI collaboratively refine the skill definition through multiple iterations.

**Content Preserved from v1 L08**:
- Concept of reusable automation patterns
- Skill creation framework

**Content Removed**:
- Deployment pattern content (moved to L12)
- Monitoring setup content (moved to L12)
- Oversized code blocks

**Content Added**:
- Persona + Questions + Principles framework for skill design
- Fresh-system testing methodology
- Explicit connection to Agent Factory thesis (skills = reusable intelligence)
- Mapping to canonical skill format

**Canonical Format Alignment**: Skill taught here MUST match `.claude/skills/<name>/SKILL.md` directory structure with YAML frontmatter (name, description). NOT flat file format. Reference checked against canonical source.

**Exercises**:
1. Task: List 3 recurring operational patterns from L05-L12 that you performed more than twice. Document them with: trigger condition, steps, expected outcome.
2. Task: Write a skill specification for "deploy-agent" that includes persona, key questions, and principles. Verify: Spec covers user creation, service file, permissions, monitoring, and validation.
3. Task: Implement the skill as a comprehensive bash script. Test on a fresh /tmp workspace. Verify: Script creates user, installs service, starts agent, and passes health check from scratch.

**Try With AI** (FR-005, Three Roles invisible):
1. "Ask Claude: 'I've deployed agents 5 times following a similar pattern: create user, set permissions, write service file, enable service, verify health. Help me formalize this as a reusable deployment skill with a Persona, Questions, and Principles structure.'" -- What you're learning: AI helps transform tacit operational knowledge into explicit, structured, reusable intelligence.
2. "Tell Claude your specific deployment variations: 'Sometimes the agent uses Python, sometimes Node.js. Ports vary. Some need GPU access. Refine the skill to handle these variations.' Review how Claude parameterizes the skill." -- What you're learning: Good skill design is parameterized for variation, not hardcoded for one scenario.
3. "Ask Claude: 'Test my deploy-agent skill specification by mentally running it on a fresh Ubuntu 22.04 server with nothing installed. What steps would fail? What prerequisites am I assuming?'" -- What you're learning: Fresh-system testing reveals hidden assumptions that make skills fail outside your configured environment.

**Skill Dependencies**: Requires ALL previous lessons (this lesson synthesizes patterns from the entire chapter)

---

### L3 -> L4 Transition Boundary

**Transition criteria met at end of L13:**
1. Intelligence accumulation: Students have created reusable deployment skills
2. Orchestration need: The capstone requires composing multiple components
3. Specification capability: Students can write clear specs (demonstrated in L12-L13 design exercises)

---

### Lesson 14: Capstone -- Spec-First Production Deployment

**Filename**: `14-capstone-production-deployment.md`
**Content Source**: REWRITE (40% preserved from v1 L09)
**Layer**: L4 (Spec-Driven)
**CEFR**: C1
**Bloom's**: Create
**Duration**: 90 min | **Size Target**: ~30KB (v1 L09 is 40KB, needs reduction)

**Learning Objectives**:
- LO-14-1: Write a deployment specification (DEPLOYMENT-SPEC.md) covering service, security, monitoring, and validation [Bloom: Create | C1]
- LO-14-2: Implement a complete agent deployment using only skills taught in this chapter [Bloom: Create | C1]
- LO-14-3: Validate deployment against specification using layered verification [Bloom: Evaluate | C1]
- LO-14-4: Package the deployment as a reproducible script [Bloom: Create | C1]

**New Concepts** (count: 5, within C1 allowance):
1. Specification-first deployment (write spec BEFORE implementation)
2. Layered validation (service -> network -> security -> monitoring checks)
3. Deployment packaging (reproducible scripts from spec)
4. Architecture decisions (systemd + direct port binding, no nginx)
5. Production readiness checklist

**Teaching Modality**: Spec-first project. Specification is written FIRST, then implemented, then validated.

**Capstone Architecture (FR-020)**: Uses systemd + direct port binding. No nginx dependency. Reverse proxy mentioned ONLY as optional future enhancement ("When you learn nginx in a future chapter, you can add a reverse proxy in front of your agent for SSL termination and load balancing.").

**Sample Agent File (FR-021)**: Introduced in this lesson. See Section V below for exact contents.

**Content Preserved from v1 L09**:
- DEPLOYMENT-SPEC.md template
- Layered validation approach
- Multi-step deployment exercise

**Content Removed**:
- ALL nginx configuration (17 references in v1)
- "Three Roles in Action" section header
- `Restart=always` references (corrected to `on-failure`)
- Forward references to Chapters 40-42
- Duplicated health check scripts (reference L10)

**Content Added**:
- Sample agent_main.py file (FR-021)
- Direct port binding architecture
- Explicit "no nginx required" note
- Verification exercises with expected outputs
- Packaging as reproducible script

**Exercises**:
1. Task: Write DEPLOYMENT-SPEC.md for the sample agent. Verify: Spec covers user, permissions, service file, monitoring, validation sections.
2. Task: Implement the spec step by step (create user, set permissions, write service file, deploy agent, start service). Verify: `systemctl is-active sample-agent` shows "active".
3. Task: Run the layered validation script. Verify: All checks pass (service running, port responding, permissions correct, logs flowing).
4. Task: Package everything into a deploy.sh script that can reproduce the deployment from scratch. Verify: `bash deploy.sh` on a clean workspace produces running agent.

**Try With AI** (FR-005, Three Roles invisible):
1. "Ask Claude: 'Review my DEPLOYMENT-SPEC.md. Are there any production concerns I haven't addressed? Here is the spec: [paste spec].' Incorporate Claude's suggestions." -- What you're learning: AI identifies gaps in specifications (like backup strategy, update procedures, rollback plans) that specification authors commonly miss.
2. "Tell Claude your deployment constraints: 'I'm deploying to a VPS with 1GB RAM and 20GB disk. The agent processes 100 requests/hour. Optimize my deployment for these constraints.' Compare to your original implementation." -- What you're learning: Providing real constraints produces deployments optimized for YOUR situation, not generic best practices.
3. "After deployment, ask Claude: 'My agent is deployed and passing health checks. What should I monitor over the next 24 hours to ensure stability? Create a monitoring checklist.' Follow the checklist and report what you observe." -- What you're learning: Production isn't done at deployment -- monitoring, alerting, and observability are ongoing responsibilities.

**Skill Dependencies**: Requires ALL previous lessons (capstone synthesizes entire chapter)

---

### Lesson 15: Chapter Quiz

**Filename**: `15-chapter-quiz.md`
**Content Source**: REGENERATE (100% new; v1 quiz had syntax bugs and only covered 9 lessons)
**Duration**: 30 min

See Section VII for quiz plan.

---

## IV. Lesson Dependency Graph

```
L01 (CLI Mindset)
 |
 v
L02 (File Operations) -----> L03 (Text Editing/Pipes)
 |                              |
 v                              v
L04 (Modern Terminal) -------> L05 (tmux)          [L1->L2 boundary]
                                |
                                v
                         L06 (Bash Scripting)
                          |          |
                          v          v
                   L07 (Text Processing)  L08 (Security)
                          |                    |
                          v                    v
                   L09 (Networking/SSH) <------+
                          |
                          v
                   L10 (Systemd) ---------> L11 (Debugging)   [L2->L3 boundary]
                          |                    |
                          v                    v
                   L12 (Workflow Integration)
                          |
                          v
                   L13 (Reusable Skills)      [L3->L4 boundary]
                          |
                          v
                   L14 (Capstone)
                          |
                          v
                   L15 (Quiz)
```

**Critical Path**: L01 -> L02 -> L03 -> L04 -> L06 -> L07 -> L10 -> L11 -> L12 -> L13 -> L14

**Parallel Tracks (within L2)**:
- L07 (text processing) and L08 (security) can be studied in either order after L06
- L09 (networking) requires L08 (SSH keys taught in security) but is flexible otherwise
- L10 (systemd) requires L09 (ports for binding) and L08 (users for service accounts)

---

## V. Sample Agent File Specification (FR-021)

### `agent_main.py` -- Exact Contents (~45 lines)

```python
"""
Sample AI Agent for Linux Mastery Chapter
==========================================
A minimal FastAPI agent used throughout Chapter 10 to practice
deployment, monitoring, and management on Linux servers.

Requirements: pip install fastapi uvicorn
Run directly: uvicorn agent_main:app --host 0.0.0.0 --port 8000
"""

from datetime import datetime
from fastapi import FastAPI

# Create the FastAPI application
# This is the "agent" that we'll deploy as a systemd service
app = FastAPI(
    title="Sample Digital FTE Agent",
    description="A minimal agent for practicing Linux deployment skills",
    version="1.0.0"
)

# Health check endpoint
# Used by monitoring scripts to verify the agent is alive
@app.get("/health")
def health_check():
    return {
        "status": "healthy",
        "agent": "running",
        "timestamp": datetime.now().isoformat()
    }

# Sample task endpoint
# Represents the agent's actual work (simplified for learning)
@app.get("/tasks")
def list_tasks():
    return {
        "tasks": [
            {"id": 1, "name": "Process customer inquiry", "status": "pending"},
            {"id": 2, "name": "Generate daily report", "status": "completed"},
            {"id": 3, "name": "Update knowledge base", "status": "in_progress"}
        ],
        "total": 3,
        "agent_uptime": "running since startup"
    }

# Entry point when running directly (not via uvicorn command)
if __name__ == "__main__":
    import uvicorn
    # Host 0.0.0.0 makes agent accessible from network (not just localhost)
    # Port 8000 is the default for development
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### Introduction Schedule

| Lesson | How agent_main.py is Used |
|--------|--------------------------|
| L10 (Process Control) | Introduced. Students deploy as systemd service. `ExecStart=/usr/bin/uvicorn agent_main:app --host 0.0.0.0 --port 8000` |
| L11 (Debugging) | Used as target for debugging exercises. Students intentionally break it and diagnose. |
| L14 (Capstone) | Full production deployment. Students write DEPLOYMENT-SPEC.md for this agent and implement the spec. |

### Constraints Validation
- Lines: 45 (within 50-line max)
- Dependencies: ONLY fastapi and uvicorn (`pip install fastapi uvicorn`)
- Endpoints: /health (returns status object) and /tasks (returns sample data)
- Comments: Every section has inline comment explaining purpose
- Self-contained: No database, no auth, no external APIs
- Install instruction: `pip install fastapi uvicorn` included in lesson text

---

## VI. Content Migration Map

### v1 Lesson 01 (cli-architect-mindset) -> v2 Lesson 01

| Section | Action | Details |
|---------|--------|---------|
| YAML frontmatter | PRESERVE + UPDATE | Add keywords, fix skills list |
| Opening narrative | REWRITE | Agent Factory framing, remove old prerequisites |
| Terminal vs shell | PRESERVE | Good content, minor edits |
| Filesystem hierarchy | PRESERVE | Good content |
| Navigation exercises | REWRITE | Add verification commands |
| Try With AI | ADD | 3 conceptual prompts (L1 pattern) |

### v1 Lesson 02 (modern-terminal-environment) -> v2 Lesson 04

| Section | Action | Details |
|---------|--------|---------|
| nano teaching | REMOVE | Moved to NEW v2 L03 |
| Package management | REWRITE | More explicit apt explanation |
| zoxide/fzf | PRESERVE | Good content |
| .bashrc config | PRESERVE | Good content |
| Environment variable scoping | REMOVE | Moved to v2 L08 (security/scoping) |
| Aliases | PRESERVE | Good content |
| Three Roles sections | REMOVE | Make invisible |

### v1 Lesson 03 (persistent-sessions-tmux) -> v2 Lesson 05

| Section | Action | Details |
|---------|--------|---------|
| tmux basics | PRESERVE | Good content |
| Pane splitting | PRESERVE | Good content |
| "Phase 2: Three Roles Demonstration" | REMOVE HEADER | Content restructured as natural exercises |
| Scripted AI conversations | REPLACE | With "Try With AI" prompts |
| Session scripts | PRESERVE | Good content |
| Monitoring layout | REWRITE | Remove nginx mentions |

### v1 Lesson 04 (bash-scripting-agent-automation) -> v2 Lessons 06 + 07

**SPLIT**: This 34KB lesson becomes two lessons.

**To v2 L06 (Bash Scripting Foundations)**:
| Section | Action | Details |
|---------|--------|---------|
| Shebang and permissions | PRESERVE | |
| Variables and quoting | PRESERVE | |
| Error handling (set -euo pipefail) | PRESERVE | |
| Functions | PRESERVE | |
| Conditionals and loops | PRESERVE | |
| `stat -f%z` | FIX | Replace with `stat -c%s` (FR-012) |
| Health check scripts | REMOVE | Consolidated to L10 (FR-017) |
| "Three Roles" section | REMOVE | Make invisible |

**To v2 L07 (Text Processing & Automation)**:
| Section | Action | Details |
|---------|--------|---------|
| grep with regex | PRESERVE | |
| sed substitution | PRESERVE | |
| awk field processing | PRESERVE | |
| Pipeline composition | PRESERVE | |
| Cron jobs | ADD | New content |
| Log rotation | ADD | New content |

### v1 Lesson 05 (security-hardening) -> v2 Lesson 08

| Section | Action | Details |
|---------|--------|---------|
| User creation | PRESERVE | Good content |
| chmod/chown | PRESERVE | Good content |
| SSH key generation | REMOVE | Moved to v2 L09 (Networking/SSH) |
| sshd_config | REMOVE | Moved to v2 L09 |
| Environment variable scoping | ADD | From v1 L02, belongs with security |
| .env file management | ADD | New content |
| "Three Roles" sections | REMOVE | Make invisible |

### v1 Lesson 06 (process-control-systemd) -> v2 Lesson 10

| Section | Action | Details |
|---------|--------|---------|
| Service file structure | PRESERVE | Good content |
| Restart=always | FIX | Change to Restart=on-failure (FR-013) |
| systemctl commands | PRESERVE | Good content |
| journalctl | PRESERVE | Good content |
| "Three Roles" section | REMOVE | Make invisible |
| nginx references | REMOVE | |
| Health check | REWRITE | Establish as CANONICAL version (FR-017) |
| Resource limits | ADD | MemoryMax, CPUQuota |
| Start-limit protection | ADD | RestartSec, StartLimitBurst |

### v1 Lesson 07 (debugging-troubleshooting) -> v2 Lesson 11

| Section | Action | Details |
|---------|--------|---------|
| journalctl diagnosis | PRESERVE | Good content |
| Network diagnosis | REWRITE | Now builds on L09 foundation |
| Disk diagnostics | PRESERVE | Good content |
| "Phase 2: Three Roles Demonstration" | REMOVE HEADER | Restructure as exercises |
| Process inspection | PRESERVE | |
| Health check scripts | REPLACE | With reference to L10 canonical |
| Structured triage | PRESERVE | Good methodology |

### v1 Lesson 08 (advanced-workflow-integration) -> v2 Lessons 12 + 13

**SPLIT**: This 48KB lesson (over 35KB limit) becomes two lessons.

**To v2 L12 (Workflow Integration Patterns)**:
| Section | Action | Details |
|---------|--------|---------|
| Deployment patterns | PRESERVE (~30%) | Blue-green, rolling |
| Monitoring integration | PRESERVE | Log rotation + health checks |
| Health check scripts | REPLACE | Reference L10 canonical (FR-017) |
| Restart=always | FIX | Correct to on-failure |
| Docker awareness | ADD | Brief comparison note (FR-014) |

**To v2 L13 (Building Reusable Skills)**:
| Section | Action | Details |
|---------|--------|---------|
| Skill creation concept | PRESERVE (~20%) | |
| Pattern recognition | REWRITE | More structured methodology |
| Persona + Questions + Principles | ADD | Constitution-aligned skill design |
| Fresh-system testing | ADD | New content |

### v1 Lesson 09 (capstone-production-deployment) -> v2 Lesson 14

| Section | Action | Details |
|---------|--------|---------|
| DEPLOYMENT-SPEC.md | PRESERVE | Core remains good |
| nginx configuration | REMOVE (17 instances) | FR-020 |
| "Three Roles in Action" header | REMOVE | Make invisible |
| Restart=always references | FIX | on-failure |
| Sample agent file | ADD | agent_main.py (FR-021) |
| Forward references (Ch 40-42) | REMOVE | FR-022, FR-023 |
| Layered validation | REWRITE | Include health check reference to L10 |
| Deployment packaging | ADD | Reproducible script exercise |

### v1 Quiz (10-chapter-quiz.md) -> v2 Lesson 15

| Aspect | Action | Details |
|--------|--------|---------|
| Question count | EXPAND | 9-lesson coverage -> 13-lesson coverage |
| JSON syntax | FIX | Remove double-comma bugs (FR-026) |
| Three Roles questions | REWRITE | Remove explicit framework references |
| New topic questions | ADD | File ops, pipes, networking, SSH |

---

## VII. Three Roles Invisibility Strategy

### Transformation Pattern

Every v1 lesson that has explicit Three Roles sections must be transformed. Here is the pattern:

**BEFORE (v1 -- visible framework)**:
```markdown
## Phase 2: Three Roles Demonstration--Collaborative tmux Workflow

### AI as Teacher: Learning Production Monitoring Layouts
Ask AI to suggest a tmux layout for monitoring...

**What to notice**: AI teaches you patterns for efficient monitoring.

### AI as Student: Teaching Domain-Specific Requirements
Tell AI about your specific agent setup...

**Key moment**: AI learned your constraints and adapted.

### AI as Co-Worker: Iterative Layout Refinement
Work with AI to refine the layout...

**What emerged**: Better solution through convergence.
```

**AFTER (v2 -- invisible framework)**:
```markdown
## Try With AI: Designing Your Agent Monitoring Workspace

**Part 1: Initial Layout Request**
Ask Claude: "I manage 3 AI agents that each need monitoring. Design a tmux
session layout that lets me monitor all 3 simultaneously. Show me the
session script."

**Part 2: Customizing for Your Setup**
Review Claude's suggestion. Now add your specific constraints:
"This layout needs adjustment--I also need a pane for editing config files
with nano, and the log panes should be smaller since I mostly glance at them."

Compare the two versions. What changed? Was the second version better?

**Part 3: Hardening**
Ask Claude: "Review this for edge cases. What happens if a session with this
name already exists? What if one of the agent log files doesn't exist yet?"

Test the final script on your system. Does it work as expected?

**What you're learning**: Building workspace layouts through iterative
refinement -- starting with a general design, adding your constraints,
and catching edge cases -- produces more robust results than designing
everything from scratch.
```

### Key Transformation Rules

1. **Remove all section headers containing**: "Three Roles", "AI as Teacher", "AI as Student", "AI as Co-Worker", "Phase 2: Three Roles Demonstration"
2. **Remove all meta-commentary**: "What to notice:", "Key moment:", "AI learned from you", "AI is teaching you"
3. **Preserve the INTERACTION PATTERN** but restructure as:
   - Part 1: Initial request (AI teaches, invisible)
   - Part 2: Constraint refinement (student teaches AI, invisible)
   - Part 3: Iterative improvement (co-worker convergence, invisible)
4. **Use natural language**: "Ask Claude:", "Review Claude's response:", "Now tell Claude:"
5. **End with reflection on WHAT EMERGED**, not on WHO TAUGHT WHOM

### Validation Command

```bash
grep -rEi "(AI as (Teacher|Student|Co-Worker)|Three Roles:|Key moment:|What to notice)" \
  apps/learn-app/docs/02-Applied-General-Agent-Workflows/10-linux-mastery/*.md
```

**Expected result**: ZERO matches (after excluding summary files which will also be regenerated).

---

## VIII. Cross-Cutting Requirements Validation Plan

### FR-004: Complete YAML Frontmatter

**Validation per lesson**:
```bash
for f in apps/learn-app/docs/02-Applied-General-Agent-Workflows/10-linux-mastery/[0-1]*.md; do
  echo "=== $f ==="
  head -80 "$f" | grep -c "skills:"
  head -80 "$f" | grep -c "learning_objectives:"
  head -80 "$f" | grep -c "cognitive_load:"
  head -80 "$f" | grep -c "differentiation:"
done
```
**Expected**: Each file shows count of 1 for each metadata section.

### FR-005: Exactly 3 "Try With AI" Prompts

**Validation per lesson**:
```bash
for f in apps/learn-app/docs/02-Applied-General-Agent-Workflows/10-linux-mastery/[0-1][0-4]*.md; do
  echo "=== $f ==="
  grep -c "Try With AI" "$f"
done
```
**Expected**: Each lesson file shows exactly 3 (some may show 1 section header + content; the count should reflect 3 distinct prompts within).

Note: For L01-L04 (L1 lessons), "Try With AI" prompts are conceptual exploration, not collaborative implementation.

### FR-006: Three Roles Invisible

**Validation**:
```bash
grep -rEi "(AI as (Teacher|Student|Co-Worker)|Three Roles:|Key moment:|What to notice)" \
  apps/learn-app/docs/02-Applied-General-Agent-Workflows/10-linux-mastery/[0-1]*.md
```
**Expected**: ZERO matches.

### FR-016: 2+ Exercises with Verification

**Validation per lesson**:
```bash
for f in apps/learn-app/docs/02-Applied-General-Agent-Workflows/10-linux-mastery/[0-1]*.md; do
  echo "=== $f ==="
  grep -ci "verify:" "$f"
done
```
**Expected**: Each file shows count >= 2.

### FR-018: No Simulated Conversations

**Validation**:
```bash
grep -c "^You:" apps/learn-app/docs/02-Applied-General-Agent-Workflows/10-linux-mastery/[0-1]*.md
```
**Expected**: ZERO across all files.

### FR-019: Max 6 New Concepts

**Validation**: Manual review of `cognitive_load.new_concepts` in YAML frontmatter.
```bash
grep -A1 "new_concepts:" apps/learn-app/docs/02-Applied-General-Agent-Workflows/10-linux-mastery/[0-1]*.md
```
**Expected**: All values <= 6.

### Full Validation Script

After all lessons are implemented, run a comprehensive validation:

```bash
#!/bin/bash
set -euo pipefail
CHAPTER_DIR="apps/learn-app/docs/02-Applied-General-Agent-Workflows/10-linux-mastery"
PASS=0
FAIL=0

echo "=== Cross-Cutting Requirements Validation ==="

# FR-006: Three Roles invisible
ROLES=$(grep -rEic "(AI as (Teacher|Student|Co-Worker)|Three Roles:|Key moment:|What to notice)" "$CHAPTER_DIR"/[0-1]*.md 2>/dev/null || true)
if [ "$ROLES" = "0" ] || [ -z "$ROLES" ]; then
  echo "[PASS] FR-006: Three Roles invisible"
  ((PASS++))
else
  echo "[FAIL] FR-006: Found $ROLES Three Roles references"
  ((FAIL++))
fi

# FR-012: No macOS stat syntax
STAT=$(grep -rc "stat -f%z" "$CHAPTER_DIR"/[0-1]*.md 2>/dev/null || true)
if [ "$STAT" = "0" ] || [ -z "$STAT" ]; then
  echo "[PASS] FR-012: No macOS stat syntax"
  ((PASS++))
else
  echo "[FAIL] FR-012: Found $STAT macOS stat references"
  ((FAIL++))
fi

# FR-018: No simulated conversations
CONVOS=$(grep -rc "^You:" "$CHAPTER_DIR"/[0-1]*.md 2>/dev/null || true)
if [ "$CONVOS" = "0" ] || [ -z "$CONVOS" ]; then
  echo "[PASS] FR-018: No simulated conversations"
  ((PASS++))
else
  echo "[FAIL] FR-018: Found $CONVOS simulated conversations"
  ((FAIL++))
fi

# FR-020: No nginx dependency in capstone
NGINX_CAP=$(grep -ci "nginx" "$CHAPTER_DIR"/14-capstone-production-deployment.md 2>/dev/null || true)
if [ "$NGINX_CAP" -le 2 ]; then
  echo "[PASS] FR-020: Minimal nginx references (awareness only)"
  ((PASS++))
else
  echo "[WARN] FR-020: Found $NGINX_CAP nginx references in capstone (should be <= 2)"
  ((FAIL++))
fi

# SC-002: File sizes under 35KB
for f in "$CHAPTER_DIR"/[0-1][0-4]*.md; do
  SIZE=$(wc -c < "$f")
  if [ "$SIZE" -gt 35840 ]; then
    echo "[FAIL] SC-002: $(basename "$f") is ${SIZE} bytes (> 35KB)"
    ((FAIL++))
  fi
done
echo "[INFO] SC-002: Size check complete"

echo ""
echo "=== Results: $PASS passed, $FAIL failed ==="
```

---

## IX. Quiz Regeneration Plan (FR-025, FR-026, FR-027)

### Structure: 50 Questions Across 13 Lessons

| Lesson | Questions | Topics |
|--------|-----------|--------|
| L01 (CLI Mindset) | 3 | Terminal vs shell, filesystem hierarchy, paths |
| L02 (File Operations) | 4 | cp/mv/rm safety, wildcards, head/tail/less, mkdir -p |
| L03 (Text Editing/Pipes) | 4 | nano shortcuts, stdin/stdout/stderr, pipes, redirection |
| L04 (Modern Terminal) | 3 | apt package management, aliases, zoxide/fzf |
| L05 (tmux) | 4 | Sessions, panes, detach/reattach, session scripts |
| L06 (Bash Scripting) | 5 | Shebang, variables, error handling, functions, loops |
| L07 (Text Processing) | 5 | grep regex, sed substitution, awk fields, cron syntax, pipelines |
| L08 (Security) | 4 | Users, permissions, chmod, env var scoping, secrets |
| L09 (Networking/SSH) | 4 | Ports, localhost vs 0.0.0.0, SSH config, ufw |
| L10 (Systemd) | 5 | Service file sections, Restart=on-failure, journalctl, resource limits |
| L11 (Debugging) | 4 | Triage methodology, disk diagnostics, process inspection, log analysis |
| L12 (Workflow Integration) | 3 | Deployment patterns, monitoring, blue-green |
| L13 (Reusable Skills) | 2 | Pattern recognition, skill specification |
| **Total** | **50** | |

### Question Type Distribution

| Type | Count | Purpose |
|------|-------|---------|
| Multiple Choice (single answer) | 30 | Factual recall and concept understanding |
| Multiple Choice (multiple answers) | 10 | Analyzing scenarios requiring multiple considerations |
| Scenario-based | 10 | Apply knowledge to debugging/deployment scenarios |

### Distractor Design (FR-027)

Each question includes distractors testing common misconceptions:

**Example**: "What does `chmod 755 script.sh` do?"
- A: Owner can read/write/execute, group and others can read/execute (CORRECT)
- B: Everyone can read/write/execute (misconception: 777 confused with 755)
- C: Owner can read/write, group and others can read only (misconception: confusing 644 with 755)
- D: Only the owner can access the file (misconception: confusing 700 with 755)

**Example**: "Why is `Restart=on-failure` preferred over `Restart=always` for production services?"
- A: `on-failure` allows controlled manual stops while still auto-restarting crashes (CORRECT)
- B: `on-failure` uses less system resources (misconception: restart policy doesn't affect resource usage)
- C: `always` only works with root services (misconception: no such restriction)
- D: There is no practical difference (misconception: ignoring the manual-stop behavior)

### JSON Syntax Validation (FR-026)

Quiz file will be validated with:
```bash
# Check for double-comma bugs
grep -n ",," apps/learn-app/docs/02-Applied-General-Agent-Workflows/10-linux-mastery/15-chapter-quiz.md
# Expected: ZERO matches
```

---

## X. Implementation Sequence

### Phase 1: New Foundational Lessons (L01-L04)

**Priority**: Highest. These are the L1 Manual Foundation. They must exist before L2 lessons can reference them.

| Order | Task | Est. Time |
|-------|------|-----------|
| 1.1 | Write L01 (CLI Mindset rewrite) | 2 hours |
| 1.2 | Write L02 (File Operations -- NEW) | 3 hours |
| 1.3 | Write L03 (Text Editing/Pipes -- NEW) | 3 hours |
| 1.4 | Write L04 (Modern Terminal rewrite) | 2 hours |
| 1.5 | Write README.md (updated prerequisites, lesson table) | 1 hour |

### Phase 2: L2 AI Collaboration Lessons (L05-L11)

**Priority**: High. These form the bulk of the chapter.

| Order | Task | Est. Time |
|-------|------|-----------|
| 2.1 | Write L05 (tmux rewrite) | 2 hours |
| 2.2 | Write L06 (Bash Scripting -- SPLIT from v1 L04) | 2.5 hours |
| 2.3 | Write L07 (Text Processing -- SPLIT from v1 L04) | 2.5 hours |
| 2.4 | Write L08 (Security rewrite) | 2.5 hours |
| 2.5 | Write L09 (Networking/SSH -- NEW) | 3 hours |
| 2.6 | Write L10 (Systemd rewrite, canonical health check) | 3 hours |
| 2.7 | Write L11 (Debugging rewrite) | 2 hours |

### Phase 3: L3-L4 Advanced Lessons (L12-L14)

**Priority**: Medium. Depends on L2 completion.

| Order | Task | Est. Time |
|-------|------|-----------|
| 3.1 | Write L12 (Workflow Integration -- SPLIT from v1 L08) | 2.5 hours |
| 3.2 | Write L13 (Reusable Skills -- SPLIT from v1 L08) | 2.5 hours |
| 3.3 | Write L14 (Capstone rewrite, agent_main.py) | 3 hours |

### Phase 4: Quiz and Validation

| Order | Task | Est. Time |
|-------|------|-----------|
| 4.1 | Write L15 (50-question quiz) | 3 hours |
| 4.2 | Run cross-cutting validation script | 0.5 hours |
| 4.3 | Fix any validation failures | 1 hour |
| 4.4 | Generate summary files for all lessons | 2 hours |
| 4.5 | Final review and size check | 1 hour |

**Total estimated implementation time**: ~42 hours

---

## XI. Skills Proficiency Progression Map

| Skill Track | L01 | L02 | L03 | L04 | L05 | L06 | L07 | L08 | L09 | L10 | L11 | L12 | L13 | L14 |
|-------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
| Filesystem Navigation | B1 | B1 | - | - | - | - | - | - | - | - | - | - | - | - |
| File Operations | - | B1 | B1 | - | - | - | - | - | - | - | - | - | - | - |
| Text Editing | - | - | B1 | - | - | - | - | - | - | - | - | - | - | - |
| Pipe Composition | - | - | B1 | - | - | - | B2 | - | - | - | - | - | - | - |
| Package Management | - | - | - | B1 | - | - | - | - | - | - | - | - | - | - |
| Shell Configuration | - | - | - | B1 | - | - | - | - | - | - | - | - | - | - |
| tmux Sessions | - | - | - | - | B2 | - | - | - | - | - | - | - | - | C1 |
| Bash Scripting | - | - | - | - | - | B2 | B2 | - | - | - | - | C1 | C1 | C1 |
| Text Processing | - | - | - | - | - | - | B2 | - | - | - | B2 | - | - | - |
| Security/Permissions | - | - | - | - | - | - | - | B2 | - | - | - | - | - | C1 |
| Networking | - | - | - | - | - | - | - | - | B2 | - | B2 | - | - | C1 |
| SSH | - | - | - | - | - | - | - | - | B2 | - | - | - | - | C1 |
| Systemd Services | - | - | - | - | - | - | - | - | - | B2 | B2 | C1 | - | C1 |
| Debugging/Triage | - | - | - | - | - | - | - | - | - | - | B2 | - | - | C1 |
| Deployment Patterns | - | - | - | - | - | - | - | - | - | - | - | C1 | - | C1 |
| Skill Design | - | - | - | - | - | - | - | - | - | - | - | - | C1 | - |

**Progression validation**: All tracks progress B1 -> B2 -> C1 (never regress). No skill appears at C1 without prior B1/B2 foundation.

---

## XII. Validation Checklist

### Chapter-Level
- [x] Chapter type identified: Technical/Code-Focused
- [x] Concept density analysis documented: 72 concepts, 5.5 avg per lesson
- [x] Lesson count justified: 13 (4 new + 2 splits + 7 rewrites)
- [x] All success criteria from spec mapped to lessons
- [x] All lessons map to at least one success criterion

### Stage Progression
- [x] L01-L04: Layer 1 (Manual Foundation, AI minimal/conceptual only)
- [x] L05-L11: Layer 2 (AI Collaboration with invisible Three Roles)
- [x] L12-L13: Layer 3 (Intelligence Design, reusable skills)
- [x] L14: Layer 4 (Spec-Driven Integration, capstone)
- [x] No spec-first before Layer 4

### Cognitive Load
- [x] Every lesson has <= 6 new concepts
- [x] B1 lessons (L01-L04): 5-6 concepts each
- [x] B2 lessons (L05-L11): 6 concepts each
- [x] C1 lessons (L12-L14): 5 concepts each

### Three Roles Invisibility
- [x] Transformation pattern documented (BEFORE -> AFTER)
- [x] Validation grep command specified
- [x] Every L2+ lesson has invisible Three Roles strategy documented

### Content Quality
- [x] FR-004 (YAML frontmatter) validation plan
- [x] FR-005 (3 Try With AI) per lesson planned
- [x] FR-006 (invisible Three Roles) validation command
- [x] FR-016 (2+ exercises with verification) per lesson
- [x] FR-018 (no simulated conversations) validation command
- [x] FR-021 (sample agent file) specified with exact contents
- [x] FR-025-027 (quiz) regeneration plan with 50 questions

### Factual Corrections
- [x] FR-012: stat -f%z -> stat -c%s identified in migration map
- [x] FR-013: Restart=on-failure taught as default from start
- [x] FR-022: Prerequisites corrected (Part 1 only)
- [x] FR-020: No nginx dependency in capstone architecture

### Dependency Graph
- [x] Skill dependencies mapped per lesson
- [x] Cross-lesson prerequisites identified
- [x] Critical path documented
- [x] No circular dependencies

---

**Document Version**: 1.0.0
**Last Updated**: 2026-02-08
**Status**: Ready for Implementation
**Next Step**: Phase 1 -- Create L01-L04 (Manual Foundation lessons) using content-implementer subagent
