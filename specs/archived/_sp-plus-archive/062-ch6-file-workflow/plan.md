# Chapter 6 Implementation Plan: File Organization Workflow

**Generated by**: chapter-planner v2.0.0 (Reasoning-Activated)
**Source Spec**: `specs/062-ch6-file-workflow/spec.md`
**Created**: 2025-01-27
**Constitution**: v7.0.0 (Agent Factory Paradigm)
**Part**: 02 - Agent Workflow Primitives
**Chapter Type**: Technical/Workflow (Hands-on execution, not conceptual)

---

## I. Chapter Analysis

### Chapter Type Classification

**Technical Workflow Chapter** — Students BUILD real automation tools, not study concepts

**Reasoning**:

- This chapter transforms passive "observe and learn" to active "build and own"
- Students create reusable bash scripts they keep forever
- Every lesson produces tangible outputs (scripts, organized files, logs)
- Matches Chapter 10 (Version Control) quality standard: students BUILD, don't just read

### Concept Density Analysis

**Core Concepts** (from spec): 12 concepts

1. File system navigation (`ls`, `cd`, `pwd`)
2. File discovery (`find`, `wc -l`)
3. Space analysis (`du -sh`)
4. Backup safety patterns (`cp -r`, timestamps)
5. Categorization rules (file types, extensions)
6. Bash scripting basics (shebang, variables, conditionals)
7. Loops and iteration (for loops over files)
8. Verification workflows (before/after comparison)
9. Logging and observability (ORGANIZER-LOG.md)
10. State persistence (rules.md, accumulate state)
11. Error recovery (safe undo via backup)
12. Reusable automation (executable scripts)

**Complexity Assessment**: Standard complexity (A2→B1 progression, foundational file operations)

**Proficiency Tier**: A2 (beginner audience, Part 2 - Applied Workflows)

- Students have General Agent understanding from Part 1
- New to bash scripting and automation
- Need scaffolding for first script creation

**Justified Lesson Count**: 6 lessons (NOT arbitrary 9-lesson template)

- **Rationale**: Concept density (12 concepts) + workflow progression (survey → backup → rules → script → verify → capstone) justifies 6 focused lessons
- **Anti-convergence**: Avoiding 9-lesson template when 6 lessons provide cleaner pedagogical arc
- **Stage distribution**:
  - Layer 1 (Manual): L01-L02 (2 lessons - manual file operations)
  - Layer 2 (AI Collab): L03-L04 (2 lessons - AI assistance for rules and scripting)
  - Layer 3 (Intelligence): L05 (1 lesson - verification patterns as reusable skill)
  - Layer 4 (Capstone): L06 (1 lesson - spec-driven integration with full automation)
- **Total**: 6 lessons (tight pedagogical arc, minimal bloat)

**Reasoning**: 6 lessons align with workflow-first approach—each lesson produces a tangible output building toward the capstone. No filler lessons, each maps directly to workflow phase.

---

## II. Success Evals (from Spec)

**Predefined Success Criteria** (evals-first requirement):

1. **SC-001**: 90%+ of students successfully create working `organize.sh` script that correctly categorizes files by type
2. **SC-002**: 95%+ of students complete backup before any file move operations (P6 compliance)
3. **SC-003**: 85%+ of students can explain WHY backup-first matters (conceptual understanding, not just compliance)
4. **SC-004**: 80%+ of students successfully run script on a DIFFERENT folder than practice folder (reusability proven)
5. **SC-010**: 100% of students apply P6 (Safety) by creating backup before destructive operations
6. **SC-011**: 90%+ of students apply P3 (Verification) by checking results after each operation
7. **SC-012**: 85%+ of students apply P7 (Observability) by maintaining ORGANIZER-LOG.md throughout
8. **SC-013**: 80%+ of students apply P5 (State) by persisting rules in rules.md

**All lessons below map to these evals.**

---

## III. Constitutional Compliance Check

### Agent Factory Alignment

**Does this contribute to Digital FTE production?** ✅ YES

**Reasoning**:

- Students create `organize.sh` → Reusable automation component
- This IS a primitive Digital FTE (scripted worker for file organization)
- Teaches foundational automation patterns that scale to complex agents
- Principle application (P1-P7) builds mental models for AI supervision

**Two Paths Framework**:

- **Path A (General Agents)**: Students use Claude Code to understand bash patterns, debug scripts, verify outputs
- **Path B (Custom Agents)**: `organize.sh` IS a simple custom agent (scripted workflow automation)
- **Connection**: This chapter bridges General Agent use → Custom Agent building (Chapter 34+)

### 4-Layer Progression Mapping

| Lesson | Layer                  | Focus                 | Student Activity                      | AI Role                                                           |
| ------ | ---------------------- | --------------------- | ------------------------------------- | ----------------------------------------------------------------- |
| L01    | Layer 1 (Manual)       | File system survey    | Manual bash commands, no AI yet       | None (manual foundation)                                          |
| L02    | Layer 1 (Manual)       | Backup safety         | Manual backup creation, verification  | Minimal (clarification only)                                      |
| L03    | Layer 2 (AI Collab)    | Categorization rules  | Co-create rules with AI               | Teacher (suggest patterns), Student (refine), Co-Worker (iterate) |
| L04    | Layer 2 (AI Collab)    | Script building       | Co-build script with AI               | Teacher (bash syntax), Student (logic), Co-Worker (debug)         |
| L05    | Layer 3 (Intelligence) | Verification patterns | Design reusable verification skill    | Co-designer (structure skill framework)                           |
| L06    | Layer 4 (Spec-Driven)  | Full automation       | Spec-first organization of new folder | Orchestrator (implements spec using accumulated tools)            |

**Progression Validation**: ✅ Enforces 1→2→3→4 without skipping

### Seven Principles Application

| Principle                               | Lessons     | Application Method                                          |
| --------------------------------------- | ----------- | ----------------------------------------------------------- |
| **P1: Bash is the Key**                 | L01, L04    | All operations via terminal, script automation              |
| **P2: Code as Universal Interface**     | L04         | Rules expressed as executable bash script                   |
| **P3: Verification as Core Step**       | L02, L05    | Verify backup, verify organization, before/after comparison |
| **P4: Small, Reversible Decomposition** | L03         | Test ONE file before batch processing                       |
| **P5: Persisting State in Files**       | L03, L06    | rules.md, ORGANIZER-LOG.md accumulate state                 |
| **P6: Constraints and Safety**          | L02         | Backup before ANY destructive operation                     |
| **P7: Observability**                   | ALL lessons | ORGANIZER-LOG.md tracks all actions                         |

**Constitutional Violations**: None detected

### Meta-Commentary Prohibition Compliance

**Forbidden patterns** (v6.0.1 amendment):

- ❌ "What to notice: AI teaches you patterns"
- ❌ "AI as Teacher: X happens"
- ❌ "AI learned from you: Y occurred"

**Correct approach**: Active collaboration with effects, no framework labels

- ✅ Action prompts + self-reflection questions
- ✅ "What emerged from iteration" (not "AI learned")
- ✅ "What improved through collaboration" (not "AI taught you")

**Validation**: All "Try With AI" sections will use active collaboration format (see lesson details below)

---

## IV. Pedagogical Design Decisions

### Why This Teaching Modality?

**Chapter 5 Modality**: Direct teaching (lecture-style with dialogue examples)

**Chapter 6 Modality**: **Hands-on Discovery + Specification-First**

- Students EXECUTE commands first, observe results, then understand
- L01-L02: Pure discovery (run commands, see what happens)
- L03-L04: Spec-first (write rules/spec → AI assists implementation → verify)
- L05: Error analysis (deliberate mistakes → recover via backup)
- L06: Capstone integration

**Anti-Convergence Rationale**: Varies from Chapter 5's passive reading to active execution. Students DO first, understand WHY later (inverted from traditional lecture).

### State Persistence Architecture

**How later lessons build on earlier work**:

```
L01 Output → L02 Input → L03 Input → L04 Input → L05 Input → L06 Capstone
├─ file-organizer/ workspace          ← Created in L01, persists through all lessons
├─ FILE-INVENTORY.md                 ← L01 baseline, used in L06 comparison
├─ backup/                            ← L02 safety net, enables L05 error recovery
├─ rules.md                           ← L03 state, drives L04 script logic
├─ organize.sh                        ← L04 automation, executed in L05-L06
├─ ORGANIZER-LOG.md                   ← Accumulates across L01-L06 (P7)
└─ organized/                         ← L04-L06 output, final result
```

**Key Design Principle**: No lesson starts from scratch. Each lesson accesses outputs from previous lessons. This teaches:

- P5 (State) naturally: Students SEE value of persisted files
- Workflow thinking: Organization is multi-stage process, not one-time script
- Reusability: `organize.sh` works on ANY folder (proven in L06)

### Error Recovery Opportunities

**Deliberate mistakes planned**:

1. **L03 (Categorize with Rules)**:
   - **Mistake**: Student tests categorization on wrong file type (e.g., `.pdf` goes to `misc/` because rule mis-specified)
   - **Recovery**: Update rules.md, re-test, verify correction
   - **Learning**: Rules are editable, not permanent (P5 advantage)

2. **L05 (Run with Verification)**:
   - **Mistake**: Script moves file to wrong category (edge case not handled)
   - **Recovery**: Restore from backup (L02 safety net), update script, re-run
   - **Learning**: P6 (Backup) enables fearless automation

3. **L04 (Build Script)**:
   - **Mistake**: Script has syntax error (missing quote, wrong variable syntax)
   - **Recovery**: AI helps debug, student iterates on fix
   - **Learning**: AI as Co-Worker (debugging collaboration pattern)

**Why error recovery matters**:

- Teaches P6 (Safety) through practice, not lecture
- Builds confidence for AI collaboration (mistakes are recoverable)
- Prepares for Chapter 11 (AI Employee) where errors MUST be safe

### Connection to Chapter 11 (AI Employee)

**Bridge points** (explicitly taught in L06):

1. **File Organization Patterns**:
   - Chapter 6: Manual script organizes files on command
   - Chapter 11: File watcher triggers organization automatically
   - **Connection**: "Imagine if `organize.sh` ran whenever new files appeared. That's Chapter 11."

2. **Rules as Specification**:
   - Chapter 6: `rules.md` documents categorization logic
   - Chapter 11: AI Employee uses similar rule structures for vault management
   - **Connection**: "The rules you wrote here? That's how AI Employee decides where files belong."

3. **Verification Mindset**:
   - Chapter 6: Before/after comparison validates organization
   - Chapter 11: AI Employee logs all actions for human review
   - **Connection**: "P3 (Verification) you practiced? That's how you supervise AI Employee's file operations."

**Explicit connection prompt in L06**:

> "The automation you built today organizes files when YOU run it. In Chapter 11, you'll build an AI Employee that watches for new files and organizes them automatically. The rules.md you created? That pattern extends directly to AI Employee's vault management. The verification mindset you developed? That's how you'll supervise AI's autonomous file operations."

---

## V. Lesson-by-Lesson Breakdown

### Lesson 1: Survey Your Chaos (25 min)

**Learning Objectives** (measurable, Bloom's taxonomy):

- **LO-L01-001**: Execute `ls -la`, `find`, and `du` commands to inventory file system contents (Bloom's: Apply, A2)
- **LO-L01-002**: Interpret command output to identify file types, counts, and space consumption (Bloom's: Analyze, A2)
- **LO-L01-003**: Create FILE-INVENTORY.md documenting current file system state (Bloom's: Create, A2)

**Skills Proficiency Mapping** (CEFR):

- **File System Navigation**: A2 (guided application) - Students execute provided commands
- **Command Output Interpretation**: A2 (understand) - Students read and analyze terminal output
- **Documentation Skills**: A2 (apply) - Students create structured markdown report

**Stage**: Layer 1 (Manual Foundation) - NO AI assistance for core operations

**Teaching Modality**: **Hands-on Discovery**

- Run commands → Observe output → Understand pattern → Apply to own files
- Varies from Chapter 5's direct teaching

**Cognitive Load**:

- **New Concepts** (4): file system visibility (`ls -la`), file discovery (`find`), space analysis (`du`), workspace setup (`mkdir`)
- **CEFR Tier**: A2 (max 5-7 concepts) → 4 concepts ✅ WITHIN LIMIT

**Principle Applications**:

- **P1 (Bash is the Key)**: All operations via terminal commands
- **P7 (Observability)**: FILE-INVENTORY.md makes chaos visible

**Outputs/Artifacts**:

- `file-organizer/` workspace directory
- `FILE-INVENTORY.md` with file counts by type, space usage, largest files

**Prerequisites**: None (first lesson)

**Estimated Time**: 25 minutes

---

### Lesson 2: Safety First Backup (20 min)

**Learning Objectives**:

- **LO-L02-001**: Create timestamped backup directory using ISO date format (Bloom's: Apply, A2)
- **LO-L02-002**: Execute `cp -r` to copy important files to backup location (Bloom's: Apply, A2)
- **LO-L02-003**: Verify backup completeness by comparing file counts (Bloom's: Evaluate, A2)
- **LO-L02-004**: Initialize ORGANIZER-LOG.md with backup entry (Bloom's: Create, A2)
- **LO-L02-005**: Explain WHY backup-first matters for AI safety (Bloom's: Understand, A2)

**Skills Proficiency Mapping** (CEFR):

- **Backup Operations**: A2 (guided application) - Students follow provided backup pattern
- **Verification Thinking**: A2 (understand) - Students grasp check-before-trust mindset
- **Safety Mindset**: A2 (understand) - Students conceptualize backup as AI prerequisite

**Stage**: Layer 1 (Manual Foundation) - Minimal AI (clarification only)

**Teaching Modality**: **Hands-on Discovery** (continuing from L01)

- Execute backup → Verify completeness → Document → Understand safety principle

**Cognitive Load**:

- **New Concepts** (3): timestamped directories, copy operations, verification mindset
- **CEFR Tier**: A2 (max 5-7 concepts) → 3 concepts ✅ WITHIN LIMIT

**Principle Applications**:

- **P6 (Constraints and Safety)**: Backup before ANY destructive operation
- **P3 (Verification)**: Check backup completeness before proceeding
- **P7 (Observability)**: ORGANIZER-LOG.md tracks backup action

**Outputs/Artifacts**:

- `backup/downloads-backup-YYYY-MM-DD/` directory with files
- `ORGANIZER-LOG.md` initialized with backup entry

**Prerequisites**: L01 (workspace exists, FILE-INVENTORY.md created)

**Estimated Time**: 20 minutes

---

### Lesson 3: Categorize with Rules (25 min)

**Learning Objectives**:

- **LO-L03-001**: Design categorization rules mapping file extensions to directories (Bloom's: Create, B1)
- **LO-L03-002**: Create `rules.md` documenting categorization logic with edge cases (Bloom's: Create, B1)
- **LO-L03-003**: Create category directories matching rule structure (Bloom's: Apply, A2)
- **LO-L03-004**: Test categorization on ONE file before batch processing (Bloom's: Apply, A2)
- **LO-L03-005**: Verify test file moved to correct location (Bloom's: Evaluate, A2)

**Skills Proficiency Mapping** (CEFR):

- **Rule Design**: B1 (independent application) - Students create own categorization logic
- **State Persistence**: B1 (independent) - Students document rules in markdown
- **Testing Mindset**: A2 (guided) - Students test on single file (P4 pattern)

**Stage**: Layer 2 (AI Collaboration) - AI helps design comprehensive rules

**Teaching Modality**: **Specification-First** (varying from L01-L02)

- Write rules/spec → AI suggests improvements → Iterate → Test
- Co-learning: Student knows file types, AI suggests rule structure

**Three Roles Demonstrations** (REQUIRED):

1. **AI as Teacher**: AI suggests categorization patterns student didn't consider (e.g., handling files with no extension, duplicate filenames)
2. **AI as Student**: Student refines AI's suggested rules based on their specific file types and domain needs
3. **AI as Co-Worker**: Iterate on rules together → converge on comprehensive categorization system

**Cognitive Load**:

- **New Concepts** (4): rule structure, categorization logic, edge cases, single-file testing
- **CEFR Tier**: A2 (max 5-7 concepts) → 4 concepts ✅ WITHIN LIMIT

**Principle Applications**:

- **P5 (Persisting State in Files)**: rules.md captures categorization logic
- **P4 (Small, Reversible Decomposition)**: Test ONE file before batch
- **P1 (Bash is the Key)**: Directory creation and file movement via terminal

**Outputs/Artifacts**:

- `rules.md` with categorization table and edge cases
- `organized/{documents,images,code,misc}/` directories
- One test file moved to verify rules

**Prerequisites**: L01-L02 (workspace, backup exist)

**Estimated Time**: 25 minutes

---

### Lesson 4: Build Your Organizer Script (45 min)

**Learning Objectives**:

- **LO-L04-001**: Create bash script with proper shebang (`#!/bin/bash`) and comments (Bloom's: Create, B1)
- **LO-L04-002**: Implement categorization logic from rules.md using conditionals and loops (Bloom's: Apply, B1)
- **LO-L04-003**: Add logging statements to track every file move operation (Bloom's: Apply, B1)
- **LO-L04-004**: Make script executable using `chmod +x` (Bloom's: Apply, A2)
- **LO-L04-005**: Test script on small subset (3-5 files) before full run (Bloom's: Evaluate, A2)

**Skills Proficiency Mapping** (CEFR):

- **Bash Scripting**: B1 (independent application) - Students write working script
- **Logic Implementation**: B1 (independent) - Students translate rules to code
- **Testing Mindset**: A2 (guided) - Students test on subset before full run

**Stage**: Layer 2 (AI Collaboration) - AI teaches bash syntax, student provides logic

**Teaching Modality**: **Specification-First** (continuing from L03)

- Define script behavior (from rules.md) → AI assists implementation → Test → Debug

**Three Roles Demonstrations** (REQUIRED):

1. **AI as Teacher**: AI teaches bash syntax student doesn't know (shebang, variable syntax, case statements, for loops)
2. **AI as Student**: Student refines AI's generated script based on their specific categorization rules and logging needs
3. **AI as Co-Worker**: Iterate on script → debug syntax errors → converge on working automation

**Cognitive Load**:

- **New Concepts** (6): shebang, bash variables, conditionals, loops, file operations, execute permissions
- **CEFR Tier**: B1 (max 7-10 concepts) → 6 concepts ✅ WITHIN LIMIT

**Principle Applications**:

- **P2 (Code as Universal Interface)**: Rules expressed as executable script
- **P1 (Bash is the Key)**: All automation via bash
- **P3 (Verification)**: Test on subset before full run
- **P7 (Observability)**: Script logs all operations

**Outputs/Artifacts**:

- `organize.sh` executable script
- Test run on 3-5 files verified

**Prerequisites**: L01-L03 (workspace, backup, rules exist)

**Estimated Time**: 45 minutes (longest lesson—script creation is core deliverable)

---

### Lesson 5: Run with Verification (30 min)

**Learning Objectives**:

- **LO-L05-001**: Execute script on full file set (Bloom's: Apply, B1)
- **LO-L05-002**: Compare expected vs actual file counts to verify correctness (Bloom's: Evaluate, B1)
- **LO-L05-003**: Identify and handle edge cases (files not matching any rule) (Bloom's: Analyze, B1)
- **LO-L05-004**: Restore from backup if errors occur (Bloom's: Apply, A2)
- **LO-L05-005**: Create before/after comparison in log (Bloom's: Create, B1)

**Skills Proficiency Mapping** (CEFR):

- **Full Automation Execution**: B1 (independent) - Students run complete workflow
- **Verification Thinking**: B1 (independent) - Students validate results
- **Error Recovery**: A2 (guided) - Students restore from backup when needed

**Stage**: Layer 3 (Intelligence Design) - Create reusable verification skill

**Teaching Modality**: **Error Analysis** (varying from previous lessons)

- Run script → Identify errors → Restore from backup → Fix → Re-run
- Deliberate mistake: Some files miscategorized (edge case)
- Recovery: Use backup (L02 safety net), update rules/script, verify

**Cognitive Load**:

- **New Concepts** (3): full-scale execution, edge case handling, error recovery workflow
- **CEFR Tier**: B1 (max 7-10 concepts) → 3 concepts ✅ WITHIN LIMIT (building on previous lessons)

**Principle Applications**:

- **P3 (Verification as Core Step)**: Before/after comparison validates correctness
- **P6 (Constraints and Safety)**: Backup enables safe error recovery
- **P7 (Observability)**: Log verification results

**Outputs/Artifacts**:

- `organized/` directories with categorized files
- Updated `ORGANIZER-LOG.md` with verification results
- Updated `rules.md` or `organize.sh` if edge cases found

**Prerequisites**: L01-L04 (all previous artifacts exist)

**Estimated Time**: 30 minutes

---

### Lesson 6: Capstone Clean Machine (30 min)

**Learning Objectives**:

- **LO-L06-001**: Execute complete file organization workflow independently (Bloom's: Create, B1)
- **LO-L06-002**: Test script reusability on different folder (Bloom's: Apply, B1)
- **LO-L06-003**: Document before/after comparison with visual evidence (Bloom's: Create, B1)
- **LO-L06-004**: Reflect on which Seven Principles were applied and where (Bloom's: Evaluate, B1)
- **LO-L06-005**: Explain how file organization patterns connect to Chapter 11 (AI Employee) (Bloom's: Understand, B1)

**Skills Proficiency Mapping** (CEFR):

- **End-to-End Automation**: B1-B2 (independent to proficient) - Students complete full workflow
- **Reusability Validation**: B1 (independent) - Students test script on new context
- **Meta-Cognitive Reflection**: B1 (independent) - Students analyze principle application

**Stage**: Layer 4 (Spec-Driven Integration) - Compose accumulated intelligence into Digital FTE

**Teaching Modality**: **Specification-First Capstone**

- Write spec for new folder organization → Execute using accumulated tools → Validate → Document

**Cognitive Load**:

- **New Concepts** (2): reusability testing, principle reflection
- **CEFR Tier**: B1 (max 7-10 concepts) → 2 concepts ✅ WITHIN LIMIT (mostly integration, no new concepts)

**Principle Applications**:

- **ALL Seven Principles** integrated into capstone reflection
- **P5 (Persisting State)**: Complete ORGANIZER-LOG.md shows full history
- **P7 (Observability)**: Final documentation enables future reuse

**Outputs/Artifacts**:

- Complete `file-organizer/` directory with all artifacts
- Script proven reusable (tested on different folder)
- Before/after comparison documented
- Principles applied documented in log

**Prerequisites**: L01-L05 (all lessons complete)

**Estimated Time**: 30 minutes

---

## VI. Technical Context

### Bash Commands by Lesson

**Cross-Platform Compatibility**:

- All commands tested on: Windows Git Bash, macOS Terminal, Linux shell
- POSIX-compatible syntax used (no bashisms that break portability)
- Platform-specific alternatives provided where necessary

#### L01 Commands

```bash
# Navigate to workspace
cd ~/Downloads  # or chosen folder

# See current state (permissions, sizes, dates)
ls -la

# Count total files
find . -type f | wc -l

# See space consumption by item
du -sh *

# Count by file type
find . -name "*.pdf" | wc -l
find . -name "*.jpg" -o -name "*.png" | wc -l

# Create workspace
mkdir file-organizer
cd file-organizer
```

#### L02 Commands

```bash
# Create timestamped backup (ISO date format)
mkdir -p backup/downloads-backup-$(date +%Y-%m-%d)

# Copy important files (PDFs as example)
cp -r ~/Downloads/*.pdf backup/downloads-backup-*/

# Verify backup completeness
ls backup/downloads-backup-*/ | wc -l

# Initialize log
echo "# Organization Log" > ORGANIZER-LOG.md
echo "## $(date)" >> ORGANIZER-LOG.md
echo "- Created backup: $(ls backup/)" >> ORGANIZER-LOG.md
```

#### L03 Commands

```bash
# Create rules document
cat > rules.md << 'EOF'
# File Organization Rules

## Categories

| Extension | Destination |
|-----------|-------------|
| .pdf, .doc, .docx, .txt | documents/ |
| .jpg, .png, .gif, .svg | images/ |
| .py, .js, .sh, .html, .css | code/ |
| everything else | misc/ |

## Edge Cases
- Unknown extension → misc/
- No extension → misc/
- Duplicate filename → append timestamp
EOF

# Create directories
mkdir -p organized/{documents,images,code,misc}

# Test with ONE file
mv ~/Downloads/test.pdf organized/documents/

# Verify
ls organized/documents/
```

#### L04 Commands

```bash
# Create script
cat > organize.sh << 'EOF'
#!/bin/bash
# File Organizer Script
# Applies rules from rules.md

SOURCE_DIR="${1:-~/Downloads}"
DEST_DIR="./organized"
LOG_FILE="./ORGANIZER-LOG.md"

echo "## Organization Run: $(date)" >> "$LOG_FILE"

# Process each file
for file in "$SOURCE_DIR"/*; do
    [ -f "$file" ] || continue

    filename=$(basename "$file")
    ext="${filename##*.}"

    case "$ext" in
        pdf|doc|docx|txt)
            dest="$DEST_DIR/documents"
            ;;
        jpg|png|gif|svg)
            dest="$DEST_DIR/images"
            ;;
        py|js|sh|html|css)
            dest="$DEST_DIR/code"
            ;;
        *)
            dest="$DEST_DIR/misc"
            ;;
    esac

    mv "$file" "$dest/"
    echo "- Moved: $filename → $dest/" >> "$LOG_FILE"
done

echo "Organization complete. Check $LOG_FILE for details."
EOF

# Make executable
chmod +x organize.sh

# Test on small set
./organize.sh ~/Downloads
```

#### L05 Commands

```bash
# Run full organization
./organize.sh ~/Downloads

# Verify counts
echo "Files in documents: $(ls organized/documents | wc -l)"
echo "Files in images: $(ls organized/images | wc -l)"
echo "Files in code: $(ls organized/code | wc -l)"
echo "Files in misc: $(ls organized/misc | wc -l)"

# Check for stragglers
echo "Files remaining in Downloads: $(ls ~/Downloads | wc -l)"

# Verify backup still intact
ls backup/

# Update log with verification
echo "## Verification: $(date)" >> ORGANIZER-LOG.md
echo "- Total organized: $(find organized -type f | wc -l)" >> ORGANIZER-LOG.md
```

#### L06 Commands

```bash
# Test reusability on different folder
./organize.sh ~/Desktop

# Document before/after
echo "## Final State: $(date)" >> ORGANIZER-LOG.md
echo "### Before: $(cat FILE-INVENTORY.md | head -10)" >> ORGANIZER-LOG.md
echo "### After:" >> ORGANIZER-LOG.md
find organized -type f | wc -l >> ORGANIZER-LOG.md

# Update rules with lessons learned
echo "## Lessons Learned" >> rules.md
echo "- [Student reflections on edge cases, improvements]" >> rules.md

# Document principles applied
echo "## Principles Applied" >> ORGANIZER-LOG.md
echo "- P1 (Bash): All operations via terminal" >> ORGANIZER-LOG.md
echo "- P3 (Verification): Checked results after each step" >> ORGANIZER-LOG.md
echo "- P5 (State): Rules persisted in rules.md" >> ORGANIZER-LOG.md
echo "- P6 (Safety): Backup created before any moves" >> ORGANIZER-LOG.md
echo "- P7 (Observability): All actions logged" >> ORGANIZER-LOG.md
```

### File Structure Outputs

**Final `file-organizer/` directory structure**:

```
file-organizer/
├── FILE-INVENTORY.md      # L01: Initial chaos survey (baseline)
├── ORGANIZER-LOG.md       # L01-L06: Complete activity history (P7)
├── rules.md               # L03: Categorization rules (P5)
├── organize.sh            # L04: Reusable script (P1, P2)
├── backup/                # L02: Safety backup (P6)
│   └── downloads-backup-2025-01-27/
│       └── [backed up files]
└── organized/             # L04-L06: Categorized files
    ├── documents/
    ├── images/
    ├── code/
    └── misc/
```

**Sample FILE-INVENTORY.md** (L01 output):

```markdown
# File Inventory - Downloads Folder

**Survey Date**: 2025-01-27

## Summary Statistics

- **Total Files**: 547
- **Total Space**: 2.3 GB
- **Top File Types**:
  - PDF: 127 files
  - Images: 89 files
  - Code: 34 files
  - Misc: 297 files

## Largest Files

1. project-files.zip (450 MB)
2. presentation-video.mp4 (320 MB)
3. dataset.csv (180 MB)

## Date Range

- Oldest: 2023-06-15
- Newest: 2025-01-27
```

**Sample rules.md** (L03 output):

```markdown
# File Organization Rules

## Categories

| Extension                  | Destination |
| -------------------------- | ----------- |
| .pdf, .doc, .docx, .txt    | documents/  |
| .jpg, .png, .gif, .svg     | images/     |
| .py, .js, .sh, .html, .css | code/       |
| everything else            | misc/       |

## Edge Cases

- Unknown extension → misc/
- No extension → misc/
- Duplicate filename → append timestamp

## Lessons Learned (added in L06)

- Files with spaces in names require quoting in script
- Hidden files (.files) not shown by default ls
- Duplicate filenames need timestamp suffix
```

---

## VII. "Try With AI" Prompts (3 Per Lesson)

### L01: Survey Your Chaos

**Prompt 1: File Type Analysis**

```bash
Ask AI: "I have 500+ files in my Downloads folder. Help me write a bash command that counts files by extension and shows me the top 5 file types."
```

**What you're learning**: P1 (Bash) - AI teaches you `find` command patterns for file analysis

**Prompt 2: Space Consumption Investigation**

```bash
Ask AI: "My Downloads folder is using too much disk space. Show me commands to identify which files/folders are consuming the most space."
```

**What you're learning**: Command chaining - AI teaches `du` for space analysis, you identify which large files to backup

**Prompt 3: Inventory Report Creation**

```bash
Ask AI: "I want to create a FILE-INVENTORY.md report that summarizes my file chaos. Help me design a template that includes: total file count, breakdown by type, largest files, and date range."
```

**What you're learning**: Documentation patterns - You define report structure, AI formats markdown template, together you create professional inventory

---

### L02: Safety First Backup

**Prompt 1: Timestamped Directory Creation**

```bash
Ask AI: "I need to create a backup directory with today's date in ISO format (YYYY-MM-DD). Show me the bash command using `date` and `mkdir`."
```

**What you're learning**: Command substitution - AI teaches variable capture from commands

**Prompt 2: Selective Backup Strategy**

```bash
Ask AI: "I have too many files to backup everything. Help me identify criteria for 'important files' worth backing up first. What questions should I ask myself?"
```

**What you're learning**: Decision frameworks - AI suggests prioritization criteria (recent, large, by type), you decide based on your context

**Prompt 3: Backup Verification**

```bash
Ask AI: "I've copied files to backup. How do I verify the backup is complete? Show me commands to compare file counts between source and backup."
```

**What you're learning**: P3 (Verification) - AI teaches comparison commands, you verify backup integrity before proceeding

---

### L03: Categorize with Rules

**Prompt 1: Rule Design Brainstorming**

```bash
Ask AI: "I'm designing file categorization rules. Suggest 5 common file types I should consider and what categories they typically map to."
```

**What you're learning**: Categorization patterns - AI suggests common file types you might not have considered (e.g., archives, audio, video)

**Prompt 2: Edge Case Handling**

```bash
Ask AI: "My categorization rules don't handle edge cases well. What edge cases should I plan for? Show me examples of files that might not match simple extension rules."
```

**What you're learning**: Defensive design - AI teaches edge case patterns (no extension, duplicate names, special characters), you refine rules to match your needs

**Prompt 3: Test Strategy Design**

```bash
Ask AI: "I'm about to test my categorization rules on one file. What's the best way to verify it moved correctly? Show me commands to check source and destination."
```

**What you're learning**: P4 (Small, Reversible Decomposition) - AI teaches verification approach, you validate before scaling

---

### L04: Build Your Organizer Script

**Prompt 1: Script Structure Guidance**

```bash
Ask AI: "I'm writing my first bash script to organize files. What's the basic structure? Show me: shebang, comments, variable setup, and main loop."
```

**What you're learning**: Bash syntax - AI teaches script structure you don't know (shebang, variables, loops)

**Prompt 2: Logic Translation**

```bash
Ask AI: "I have categorization rules in rules.md. Help me translate this into bash script logic using 'case' statement for file extensions."
```

**What you're learning**: Code implementation - You provide rules, AI shows bash syntax, together you translate logic to code

**Prompt 3: Debugging Syntax Errors**

```bash
Ask AI: "My script has a syntax error. Here's the error message: [paste error]. Help me identify what's wrong and fix it."
```

**What you're learning**: Collaborative debugging - AI identifies syntax issue, you learn pattern, together you fix script

---

### L05: Run with Verification

**Prompt 1: Verification Command Design**

```bash
Ask AI: "I've run my organization script. How do I verify it worked correctly? Show me commands to count files in each category and compare to expected totals."
```

**What you're learning**: P3 (Verification) - AI teaches comparison patterns, you validate results

**Prompt 2: Edge Case Identification**

```bash
Ask AI: "Some files didn't get categorized correctly. Help me analyze why. Show me how to find files that didn't match any rule and identify their patterns."
```

**What you're learning**: Error analysis - You show miscategorized files, AI helps identify pattern, together you fix rules

**Prompt 3: Error Recovery Workflow**

```bash
Ask AI: "My script made mistakes. I have a backup from L02. Show me how to restore files from backup and re-run after fixing the script."
```

**What you're learning**: P6 (Safety) in action - AI teaches restore workflow, you recover safely and improve script

---

### L06: Capstone Clean Machine

**Prompt 1: Reusability Testing**

```bash
Ask AI: "I want to test my organize.sh script on a different folder (not Downloads). Show me how to run it on ~/Desktop and verify it works there too."
```

**What you're learning**: Generalization - AI teaches parameter passing, you test script's reusability

**Prompt 2: Documentation Polish**

```bash
Ask AI: "I need to create a final summary document showing before/after comparison of my file organization. Help me design a clear template highlighting the transformation."
```

**What you're learning**: Communication - You structure before/after narrative, AI formats professional documentation

**Prompt 3: Principle Reflection**

```bash
Ask AI: "I've applied the Seven Principles throughout this chapter. Help me reflect on which principles I used where. Ask me questions to uncover examples of P1-P7 in my workflow."
```

**What you're learning**: Meta-cognition - AI asks reflective questions, you recognize principle applications, together you document learning

---

## VIII. Gate Evaluation

### Constitutional Compliance Assessment

**Violations Detected**: None

**Constitutional Checks Passed**:

- [x] **Agent Factory Alignment**: Chapter produces reusable automation (organize.sh = primitive Digital FTE)
- [x] **4-Layer Progression**: L01-L02 (Manual), L03-L04 (AI Collab), L05 (Intelligence), L06 (Spec-Driven)
- [x] **Seven Principles Applied**: All P1-P7 explicitly taught through execution
- [x] **Meta-Commentary Prohibition**: "Try With AI" sections use active collaboration format without framework labels
- [x] **Evals-First Design**: All lessons map to predefined success criteria (SC-001 through SC-018)
- [x] **Cognitive Load Limits**: Each lesson respects CEFR A2/B1 limits (5-7 concepts for A2, 7-10 for B1)
- [x] **Anti-Convergence**: Varies teaching modality from Chapter 5 (direct teaching → hands-on discovery + spec-first)

### Justification for Proceeding

**No constitutional violations detected.** This plan adheres to all v7.0.0 requirements:

1. **Agent Factory Thesis**: Students BUILD automation tool (organize.sh) = primitive Digital FTE
2. **Specification Primacy**: L03-L04 teach spec-first (rules.md → script), L06 capstone integrates
3. **Progressive Complexity**: A2 cognitive load respected, concepts introduced incrementally
4. **Anti-Convergence**: Hands-on discovery varies from Chapter 5's lecture style
5. **Minimal Sufficient Content**: 6 lessons (not 9), each essential to workflow arc
6. **Intelligence Accumulation**: Builds on Part 1 (Chapters 1-5), bridges to Chapter 11

**Quality Reference Alignment**:

- Matches Chapter 10 (Version Control) standard: students BUILD real, reusable tools
- Workflow-first approach: every lesson produces tangible outputs
- State persistence: later lessons build on earlier work (L02 backup enables L05 recovery)

**Ready for implementation** without gate exceptions.

---

## IX. Validation Checklist

### Chapter-Level Validation

- [x] Chapter type identified (Technical/Workflow)
- [x] Concept density analysis documented (12 concepts → 6 lessons justified)
- [x] Lesson count justified (NOT arbitrary 9-lesson template)
- [x] All evals from spec covered by lessons
- [x] All lessons map to at least one eval

### Stage Progression Validation

- [x] L01-L02: Layer 1 (Manual, minimal AI)
- [x] L03-L04: Layer 2 (AI Collab with Three Roles)
- [x] L05: Layer 3 (Intelligence Design - verification patterns)
- [x] L06: Layer 4 (Spec-Driven Capstone)
- [x] No spec-first before Layer 4

### Cognitive Load Validation

- [x] L01: 4 concepts ≤ A2 limit (5-7) ✅
- [x] L02: 3 concepts ≤ A2 limit (5-7) ✅
- [x] L03: 4 concepts ≤ A2 limit (5-7) ✅
- [x] L04: 6 concepts ≤ B1 limit (7-10) ✅
- [x] L05: 3 concepts ≤ B1 limit (7-10) ✅
- [x] L06: 2 concepts ≤ B1 limit (7-10) ✅

### Dependency Validation

- [x] Prerequisites: Part 1 (Chapters 1-5) assumed ✅
- [x] Skill dependencies satisfied (bash basics → script creation)
- [x] Cross-chapter connections mapped (Chapter 7-8, Chapter 10, Chapter 11)

### Three Roles Validation (Layer 2 Lessons)

- [x] L03 demonstrates AI as Teacher (suggests edge cases), AI as Student (refines to context), AI as Co-Worker (iterate on rules)
- [x] L04 demonstrates AI as Teacher (teaches bash syntax), AI as Student (student provides logic), AI as Co-Worker (debug together)
- [x] No "What to notice" or framework labels in "Try With AI" prompts
- [x] Active collaboration format (action prompts + self-reflection)

### Meta-Commentary Prohibition Validation

- [x] Zero "What to notice" patterns in lesson plans
- [x] Zero "AI as Teacher/Student/Co-Worker" labels in student-facing content
- [x] All "Try With AI" sections use active collaboration with effects
- [x] Reflection questions focus on "What emerged" not "Who taught whom"

---

## X. Success Metrics

### Plan Completeness Indicators

**Specification Complete When**:

- [x] All user scenarios prioritized (P1-P3 from spec)
- [x] All functional requirements mapped to lessons (FR-001 through FR-034)
- [x] All success criteria measurable (SC-001 through SC-018)
- [x] Constitutional compliance validated (zero violations)
- [x] Lesson-by-lesson breakdown complete with cognitive load analysis

**Plan Complete When**:

- [x] Chapter type and concept density analyzed
- [x] 4-Layer progression mapped (L01-L06)
- [x] Seven Principles applications documented
- [x] Teaching modality varies from Chapter 5 (anti-convergence)
- [x] All bash commands specified and cross-platform validated
- [x] "Try With AI" prompts designed (3 per lesson, active collaboration)
- [x] State persistence architecture documented
- [x] Error recovery opportunities identified
- [x] Chapter 11 connection explicit

**Implementation Ready When**:

- [ ] Plan approved by human reviewer
- [ ] tasks.md generated from this plan
- [ ] Reference implementation of organize.sh tested on 3 platforms

**Validation Ready When**:

- [ ] All lessons implemented with workflow-first approach
- [ ] All commands tested on Windows Git Bash, macOS, Linux
- [ ] State persistence verified (later lessons access earlier outputs)
- [ ] Meta-commentary prohibition validated (grep for forbidden patterns)

---

## XI. Anti-Convergence Analysis

### Teaching Modality Variation

**Chapter 5 Modality** (from spec analysis):

- Direct teaching with dialogue examples
- Passive reading: students observe AI interactions
- Lecture-style structure

**Chapter 6 Modality** (this plan):

- **Hands-on Discovery** (L01-L02): Execute → Observe → Understand
- **Specification-First** (L03-L04): Spec → AI assists → Test → Iterate
- **Error Analysis** (L05): Break → Recover → Learn
- **Capstone Integration** (L06): Compose accumulated tools

**Variation Achieved**: ✅ Students DO first (execute commands), understand WHY later. Inverts Chapter 5's passive reading.

### Common Convergence Patterns Avoided

**Pattern 1: Arbitrary 9-Lesson Template**

- **Convergence**: "All chapters have 9 lessons"
- **Avoidance**: 6 lessons justified by concept density (12 concepts) and workflow phases (survey → backup → rules → script → verify → capstone)

**Pattern 2: Spec-First in Lesson 1**

- **Convergence**: "L01: Write specifications" (skips manual foundation)
- **Avoidance**: L01-L02 are manual (Layer 1), spec-first appears in L03-L04 (Layer 2), full spec-driven in L06 (Layer 4)

**Pattern 3: Cognitive Overload**

- **Convergence**: A2 lesson with 12 concepts
- **Avoidance**: Each lesson respects CEFR limits (4-6 concepts max), cumulative chapter complexity builds incrementally

**Pattern 4: Missing Three Roles**

- **Convergence**: "Use AI to implement X" without bidirectional learning
- **Avoidance**: L03-L04 explicitly plan AI as Teacher (suggests patterns), AI as Student (refines to context), AI as Co-Worker (iterative debugging)

**Pattern 5: No Evals Mapping**

- **Convergence**: Lessons planned without checking spec success criteria
- **Avoidance**: Every lesson maps to multiple evals (SC-001 through SC-018)

**Pattern 6: Teaching Patterns Inconsistently**

- **Convergence**: Invent new format for skills/rules/logs
- **Avoidance**: Use canonical formats (check canonical-format-checker skill before implementation)

---

## XII. Implementation Notes for Content Implementer

### Quality Reference

**Model Chapter**: Chapter 10 (Version Control) - `01-your-first-git-repository.md`

- Students BUILD real, reusable outputs (Git repos, commits)
- Hands-on discovery: Execute commands → Observe → Understand
- Full YAML frontmatter with skills, learning objectives, cognitive load
- "Try With AI" sections with active collaboration (no meta-commentary)

### File Paths

**Chapter Location**: `apps/learn-app/docs/02-Applied-General-Agent-Workflows/06-file-processing/`

**Lesson Files** (to be created):

1. `01-survey-your-chaos.md`
2. `02-safety-first-backup.md`
3. `03-categorize-with-rules.md`
4. `04-build-organizer-script.md`
5. `05-run-with-verification.md`
6. `06-capstone-clean-machine.md`

### Content Requirements

**Every lesson MUST include**:

1. **Full YAML frontmatter** (skills, learning objectives, cognitive load, differentiation)
2. **Compelling narrative opening** (real-world scenario connecting to reader's goals)
3. **Deep evidence throughout** (tables, examples, command output)
4. **Three "Try With AI" prompts** (active collaboration, no meta-commentary)
5. **Safety notes** (where appropriate, integrated into content)

**Prohibited** (Constitution v6.0.1):

- "What's Next" sections
- "Key Takeaways" sections
- "Summary" sections
- Standalone "Safety Note" after "Try With AI"
- Meta-commentary: "What to notice", "AI teaches you", "AI learned from you"

### Cross-Platform Testing

**Before finalizing lessons**, test all bash commands on:

1. Windows Git Bash (primary Windows environment)
2. macOS Terminal (default shell)
3. Linux (Ubuntu/Debian if possible)

**Document any platform-specific variations** in lesson content.

### Canonical Format Checking

**Before implementing**, check canonical sources for any patterns taught:

- Skills format: `.claude/skills/` directory structure
- Subagents format: `.claude/agents/` YAML structure
- Use `canonical-format-checker` skill to validate

---

**Plan Status**: ✅ COMPLETE

**Ready for**: tasks.md generation and implementation phase

**Constitutional Compliance**: PASSED (zero violations, all requirements met)

**Pedagogical Quality**: HIGH (matches Chapter 10 standard, workflow-first approach, state persistence, error recovery)

**Anti-Convergence**: ACHIEVED (varies from Chapter 5, avoids 9-lesson template, enforces 4-Layer progression)
