# Implementation Plan: Chapter 34 — OpenAI Agents SDK (Production Mastery)

**Generated by**: chapter-planner v2.0.0 (Reasoning-Activated)
**Source Spec**: `/specs/047-ch34-openai-agents-sdk/spec.md`
**Constitution**: v7.0.0 (Agent Factory Paradigm)
**Created**: 2025-12-26
**Updated**: 2025-12-29
**Status**: Ready for Lesson Implementation

---

## I. Chapter Analysis

### Vision: BUILD Phase of the Digital FTE Journey

This chapter is the **BUILD** phase of creating Digital Full-Time Equivalents (Digital FTEs):

| Phase | Chapter | Outcome |
|-------|---------|---------|
| **BUILD** | **Ch34: OpenAI Agents SDK** | Working production agent system |
| DISTRIBUTE | Ch42: OpenAI Apps SDK | Package for 800M+ user marketplace |
| DEPLOY | Part 7: Cloud-Native | Kubernetes, scaling, monitoring |

Students master the infrastructure powering ChatGPT's agentic features—building autonomous digital workers that maintain context, hand off to specialists, self-validate, persist memory, produce debuggable traces, and integrate external knowledge via MCP and RAG.

### Chapter Type Recognition

**Classification**: Technical/Code-Focused

- **Recognition signals**: Spec focuses on API mastery (FR-001 through FR-055), code examples required in every lesson, learning objectives use "implement/build/create" verbs
- **Structure**: Sequential lessons (10 total) that build from SDK basics through production patterns to capstone
- **Content elements**: Code examples with type hints, practical exercises using TaskManager running example, technical assessments
- **Closure**: Layer 4 Capstone producing complete Customer Support Digital FTE with monetization discussion

### Concept Density Analysis

**Core Concepts** (from spec—excluding sub-concepts and examples):

1. Agent primitives (Agent class, Runner, execution lifecycle)
2. Function tools (@function_tool decorator, type hints, docstrings)
3. Context objects (Pydantic models, RunContextWrapper, state mutations)
4. Agents as tools (agent.as_tool(), custom_output_extractor, orchestration)
5. Agent composition (agent.clone(), tool lists, dynamic tooling)
6. Handoffs (basic lists, handoff() function, callbacks, context injection)
7. Message filtering (HandoffInputData, input_filter, handoff_filters utilities)
8. Guardrails (input/output guardrails, agent-based validation, tripwires)
9. Sessions (SQLiteSession, file persistence, history management)
10. Advanced sessions (AdvancedSQLiteSession, branching, usage tracking)
11. Lifecycle hooks (RunHooks, event callbacks, lifecycle phases)
12. Tracing (gen_trace_id(), trace(), custom_span(), group_id linking)
13. MCP integration (MCPServerStreamableHttp, mcp_servers configuration, remote tools)
14. Agentic RAG (FileSearchTool, vector_store_ids, agent-driven retrieval)
15. Conversation loops (to_input_list(), result.last_agent, conversation management)
16. Digital FTE monetization (subscription, success fee, hybrid models)

**Complexity Assessment**: Complex technical patterns

- Advanced complexity: 16 core concepts
- B1-B2 → C1 proficiency transition
- Sequential dependencies across lessons

**Proficiency Tier**: B1-B2 → C1 (from spec: "Build production FTEs")

- B1-B2: Early lessons (SDK setup, basic patterns)
- C1: Later lessons (MCP, RAG, multi-agent orchestration, monetization)

**Justified Lesson Count**: 10 lessons

**Reasoning for 10 lessons**:

| Layer | Lessons | Focus |
|-------|---------|-------|
| Layer 1 (Manual Foundation) | L1-L2 | SDK primitives, basic patterns without AI |
| Layer 2 (AI Collaboration) | L3-L7 | Function tools, context, handoffs, guardrails, sessions, tracing with Three Roles |
| Layer 3 (Intelligence Design) | L8-L9 | Create reusable skills (MCP integration, RAG patterns) |
| Layer 4 (Spec-Driven Capstone) | L10 | Customer Support FTE with spec-first orchestration |

**Total**: 10 lessons (justified by 16 core concepts + proficiency tier transition B1→C1 + Layer 3 skill creation for MCP/RAG)

---

## II. Success Criteria Mapping (12 Evals from Spec)

**Specification's Predefined Success Criteria** (evals-first requirement):

| Eval ID | Success Criterion | Lesson(s) | Assessment Type |
|---------|-------------------|-----------|-----------------|
| **SC-001** | Students can implement context objects that persist across tools and agents | L2, L3 | Hands-on: Create context model + tools accessing context |
| **SC-002** | Students can build orchestrator with 3+ sub-agents as tools | L3, L10 | Hands-on: Implement manager agent + 3 specialist agents |
| **SC-003** | Students can implement handoff with callback that injects runtime data | L4 | Hands-on: Implement on_handoff callback with context mutation |
| **SC-004** | Students can implement agent-based guardrail with structured output | L5 | Hands-on: Create guardrail agent + detect violations |
| **SC-005** | Students can use AdvancedSQLiteSession with branching | L6 | Hands-on: Branch conversation, merge histories |
| **SC-006** | Students can implement full RunHooks with usage tracking | L7 | Hands-on: Log all lifecycle events, track token usage |
| **SC-007** | Students can trace multi-agent workflow with custom spans | L7 | Hands-on: Generate trace with sub-spans, view in dashboard |
| **SC-008** | Students can connect agents to MCP servers using StreamableHTTP | L8 | Hands-on: Connect to Context7 MCP server |
| **SC-009** | Students can implement agentic RAG with FileSearchTool | L9 | Hands-on: Configure FileSearchTool with vector store |
| **SC-010** | Capstone integrates all 9 lessons into production-ready Digital FTE | L10 | Validated: Customer Support FTE implements all criteria |
| **SC-011** | Students can articulate monetization model for their Digital FTE | L10 | Discussion: Subscription/success fee/hybrid analysis |
| **SC-012** | Students understand BUILD → DISTRIBUTE → DEPLOY journey | L10 | Reflection: What's next (Ch42, Part 7) |

**All lessons map to evals. All evals covered.**

---

## III. Lesson Sequence (10 Lessons)

### Lesson 1: SDK Setup & First Agent (Layer 1: Manual Foundation)

**Learning Objective**: Set up OpenAI Agents SDK and run a functional agent without AI assistance

**Stage**: Layer 1 (Manual Foundation — no AI collaboration yet)

**CEFR Proficiency**: B1 (independent language use)

**New Concepts** (count: 6 ≤ B1 limit of 10):

1. SDK installation (`pip install openai-agents` and `pip install "openai-agents[litellm]"`)
2. API key configuration (OPENAI_API_KEY environment variable)
3. Agent class and instantiation
4. Runner.run_sync() execution pattern
5. Basic prompting and response handling
6. LiteLLM model alternative (LitellmModel with anthropic/claude-3-5-sonnet)

**Cognitive Load Validation**: 6 new concepts ≤ B1 limit (10) → WITHIN LIMIT

**Maps to FRs**: FR-001 through FR-005

**Content Elements**:

- **Setup section** (5-10 min): Step-by-step SDK installation, environment configuration
- **Hello World example** (15-20 min): Create minimal agent that greets user, run with Runner.run_sync()
- **Manual execution** (10-15 min): Students execute basic agent by hand, observe responses
- **LiteLLM alternative** (10-15 min): Demonstrate same agent using LitellmModel("anthropic/claude-3-5-sonnet")
- **Tracing disabled for non-OpenAI**: Show `set_tracing_disabled(True)` for LiteLLM models
- **No AI assistance**: Students type code by hand, understand basic flow without AI collaboration

**Prerequisites**: Chapter 33 (Conceptual introduction to agents), Part 5 Python skills

**Estimated Time**: 50-60 minutes

---

### Lesson 2: Function Tools & Context Objects (Layer 1: Manual Foundation)

**Learning Objective**: Implement function tools with type hints and context objects that persist state across tool calls

**Stage**: Layer 1 (Manual Foundation — manual tool creation, no AI yet)

**CEFR Proficiency**: B1

**New Concepts** (count: 7 ≤ B1 limit of 10):

1. @function_tool decorator for tool definition
2. Type hints in function signatures (e.g., `name: str`, `age: int`)
3. Docstrings as tool descriptions
4. Pydantic BaseModel for context objects
5. `RunContextWrapper[ContextType]` type annotation
6. Context access in tool functions (`context.context.attribute`)
7. State mutations persisting across tool calls

**Cognitive Load Validation**: 7 new concepts ≤ B1 limit (10) → WITHIN LIMIT

**Maps to Evals**: SC-001 (context objects persist across tools)
**Maps to FRs**: FR-006 through FR-010

**Content Elements**:

- **Function tool basics** (15-20 min): Decorator syntax, type hints, docstrings
- **Context model definition** (15-20 min): Create TaskManagerContext with user_id, current_project, tasks_added
- **Tool implementation** (15-20 min): Implement add_task() tool that accesses and mutates context
- **Manual execution** (10-15 min): Run agent, call tool, observe context mutations
- **Multiple tools** (10-15 min): Add multiple tools that all modify same context

**Prerequisites**: Lesson 1 (SDK setup), Part 5 Python (type hints, Pydantic Chapter 30)

**Estimated Time**: 65-75 minutes

---

### Lesson 3: Agents as Tools & Orchestration (Layer 2: AI Collaboration)

**Learning Objective**: Build orchestrator agent that calls specialist agents as tools using AI collaboration patterns

**Stage**: Layer 2 (AI Collaboration with Three Roles)

**CEFR Proficiency**: B1-B2

**New Concepts** (count: 5 ≤ B1 limit of 10):

1. `agent.as_tool()` for converting agents to tools
2. tool_name and tool_description for agent tools
3. `custom_output_extractor` for structured output control
4. Orchestrator pattern (manager agent coordinates specialists)
5. `agent.clone()` for dynamic composition

**Cognitive Load Validation**: 5 new concepts ≤ B1 limit (10) → WITHIN LIMIT

**Maps to Evals**: SC-002 (orchestrator with 3+ sub-agents)
**Maps to FRs**: FR-011 through FR-015

**Three Roles Demonstrations** (REQUIRED for Layer 2 — invisible to students):

- **AI as Teacher**: Suggests agent.as_tool() pattern and custom_output_extractor strategy student didn't know
- **AI as Student**: Adapts to student's domain constraints (TaskManager info needs vs generic agent)
- **Co-Worker**: Iterates toward dynamic agent composition for runtime flexibility

**Content Elements**:

- **Agent as tool concept** (10-15 min): Theory - how agents become orchestrator tools
- **Orchestrator pattern** (15-20 min): Implement manager agent with planning + execution specialists
- **Custom output extraction** (15-20 min): Control what sub-agent output flows forward
- **Agent cloning** (10-15 min): Runtime composition with agent.clone(tools=[...])
- **Contrast with handoffs** (5-10 min): Who owns the conversation?
- **Try With AI** (20-25 min): Explicit collaboration showing all three roles (invisible framework)
- **Practice exercise** (15-20 min): Students implement new orchestrator with 3+ specialist agents

**Prerequisites**: Lessons 1-2, Chapter 33 conceptual foundation

**Estimated Time**: 75-100 minutes

---

### Lesson 4: Handoffs & Message Filtering (Layer 2: AI Collaboration)

**Learning Objective**: Implement handoff patterns with callbacks and message filtering for context-preserving transfers

**Stage**: Layer 2 (AI Collaboration with Three Roles)

**CEFR Proficiency**: B1-B2

**New Concepts** (count: 6 ≤ B1 limit of 10):

1. Basic handoffs list (`handoffs=[agent1, agent2]`)
2. `handoff()` function with agent parameter
3. `on_handoff` callback for context injection
4. `HandoffInputData` structure for message filtering
5. `input_filter` parameter for transforming history
6. `handoff_filters.remove_all_tools` and other utility filters

**Cognitive Load Validation**: 6 new concepts ≤ B1 limit (10) → WITHIN LIMIT

**Maps to Evals**: SC-003 (handoff with callback that injects runtime data)
**Maps to FRs**: FR-016 through FR-020

**Three Roles Demonstrations** (REQUIRED for Layer 2 — invisible to students):

- **AI as Teacher**: Suggests on_handoff callbacks for context injection pattern
- **AI as Student**: Learns to filter history based on specialist information needs
- **Co-Worker**: Discovers bidirectional handoff pattern (specialist can hand back)

**Content Elements**:

- **Handoff basics** (10-15 min): Simple handoffs list, agent transfer
- **on_handoff callbacks** (15-20 min): Context injection before handoff
- **Message filtering** (15-20 min): Filter history before sending to specialist
- **Bidirectional handoffs** (10-15 min): Specialist can hand back to orchestrator
- **Try With AI** (20-25 min): Explicit collaboration scenarios (invisible framework)
- **Practice exercise** (15-20 min): Implement bidirectional handoffs in TaskManager

**Prerequisites**: Lessons 1-3, context objects from Lesson 2

**Estimated Time**: 75-100 minutes

---

### Lesson 5: Guardrails & Agent-Based Validation (Layer 2: AI Collaboration)

**Learning Objective**: Implement input/output guardrails with agent-based validation using structured outputs

**Stage**: Layer 2 (AI Collaboration with Three Roles)

**CEFR Proficiency**: B2

**New Concepts** (count: 6 ≤ B1 limit of 10):

1. `@input_guardrail` decorator for input validation
2. `@output_guardrail` decorator for output validation
3. `GuardrailFunctionOutput` with tripwire_triggered flag
4. Agent-based guardrails (guardrail calls another agent for LLM reasoning)
5. Exception handling (`InputGuardrailTripwireTriggered`)
6. Structured output validation patterns

**Cognitive Load Validation**: 6 new concepts ≤ B1 limit (10) → WITHIN LIMIT

**Maps to Evals**: SC-004 (agent-based guardrail with structured output)
**Maps to FRs**: FR-021 through FR-025

**Three Roles Demonstrations** (REQUIRED for Layer 2 — invisible to students):

- **AI as Teacher**: Teaches agent-based validation vs simple regex checks
- **AI as Student**: Learns semantic distinctions (request vs mention of topic)
- **Co-Worker**: Discovers user-friendly validation messages through iteration

**Content Elements**:

- **Guardrail decorator basics** (10-15 min): @input_guardrail syntax, return structure
- **Simple validation** (10-15 min): String checks, basic guards
- **Agent-based guardrails** (15-20 min): Guardrail agent calls another agent for reasoning
- **Structured outputs** (10-15 min): GuardrailFunctionOutput with reasoning
- **Exception handling** (10-15 min): Catch InputGuardrailTripwireTriggered
- **Practical example** (10-15 min): PII/topic detection guardrail
- **Try With AI** (20-25 min): Collaboration scenarios (invisible framework)
- **Practice exercise** (15-20 min): Implement PII detector guardrail for TaskManager

**Prerequisites**: Lessons 1-4, Pydantic output models

**Estimated Time**: 75-100 minutes

---

### Lesson 6: Sessions & Conversation Memory (Layer 2: AI Collaboration)

**Learning Objective**: Persist conversation state using SQLiteSession and AdvancedSQLiteSession with branching capabilities

**Stage**: Layer 2 (AI Collaboration with Three Roles)

**CEFR Proficiency**: B2

**New Concepts** (count: 6 ≤ B1 limit of 10):

1. `SQLiteSession` for basic persistence
2. File-based session storage (session_id + file path)
3. `session.get_items(limit=N)` for history retrieval
4. `AdvancedSQLiteSession` for production scenarios
5. `store_run_usage()` for token tracking
6. `create_branch_from_turn()` for conversation branching

**Cognitive Load Validation**: 6 new concepts ≤ B1 limit (10) → WITHIN LIMIT

**Maps to Evals**: SC-005 (AdvancedSQLiteSession with branching)
**Maps to FRs**: FR-026 through FR-030

**Three Roles Demonstrations** (REQUIRED for Layer 2 — invisible to students):

- **AI as Teacher**: Teaches AdvancedSQLiteSession for production persistence
- **AI as Student**: Learns reliability requirement (data survival across crashes)
- **Co-Worker**: Discovers efficient branching through resource consideration

**Content Elements**:

- **SQLiteSession basics** (10-15 min): Basic persistence, file storage
- **Session management** (10-15 min): Retrieve history, replay conversation
- **AdvancedSQLiteSession** (15-20 min): Token tracking, branching
- **Conversation branching** (15-20 min): Create branch from turn, switch branches
- **Try With AI** (20-25 min): Collaboration scenarios (invisible framework)
- **Practice exercise** (15-20 min): Implement branching for TaskManager

**Prerequisites**: Lessons 1-5

**Estimated Time**: 75-100 minutes

---

### Lesson 7: Tracing, Hooks & Observability (Layer 2: AI Collaboration)

**Learning Objective**: Implement lifecycle hooks and custom tracing for multi-agent workflow observability

**Stage**: Layer 2 (AI Collaboration with Three Roles)

**CEFR Proficiency**: B2 → C1

**New Concepts** (count: 7 ≤ B1 limit of 10):

1. `RunHooks` class with lifecycle methods
2. Lifecycle events (on_agent_start, on_llm_start, on_tool_start, on_handoff, on_agent_end, etc.)
3. `gen_trace_id()` for unique trace identification
4. `trace()` context manager for span grouping
5. `custom_span()` for sub-operation tracing
6. `group_id` for linking related traces
7. `context.usage` token counting

**Cognitive Load Validation**: 7 new concepts ≤ B1 limit (10) → WITHIN LIMIT

**Maps to Evals**: SC-006 (RunHooks with usage tracking), SC-007 (multi-agent trace with custom spans)
**Maps to FRs**: FR-031 through FR-035

**Three Roles Demonstrations** (REQUIRED for Layer 2 — invisible to students):

- **AI as Teacher**: Teaches observability infrastructure patterns
- **AI as Student**: Learns to prioritize signals (reduce noise)
- **Co-Worker**: Discovers end-to-end trace correlation through iteration

**Content Elements**:

- **RunHooks lifecycle** (10-15 min): All lifecycle methods and when they fire
- **Lifecycle events** (15-20 min): What happens at each event, available context
- **Token usage tracking** (10-15 min): Access context.usage in hooks, calculate costs
- **Trace generation** (15-20 min): gen_trace_id(), trace context manager, dashboard URL
- **Custom spans** (10-15 min): custom_span() for sub-operations
- **Trace correlation** (10-15 min): group_id for linking multi-turn conversations
- **Try With AI** (20-25 min): Collaboration scenarios (invisible framework)
- **Practice exercise** (15-20 min): Implement full hooks + tracing for TaskManager

**Prerequisites**: Lessons 1-6

**Estimated Time**: 90-110 minutes

---

### Lesson 8: MCP Integration (Layer 3: Intelligence Design)

**Learning Objective**: Connect agents to external MCP servers using StreamableHTTP for documentation lookup and tool ecosystems

**Stage**: Layer 3 (Intelligence Design — create reusable skill)

**CEFR Proficiency**: C1

**New Concepts** (count: 5):

1. `MCPServerStreamableHttp` for remote server connections
2. `mcp_servers=[server]` parameter on Agent
3. Async context manager pattern for MCP server lifecycle
4. MCP tool discovery (resolve-library-id, get-library-docs from Context7)
5. Agent-MCP integration pattern

**Cognitive Load Validation**: 5 new concepts (C1 allows higher complexity) → ACCEPTABLE

**Maps to Evals**: SC-008 (connect agents to MCP servers using StreamableHTTP)
**Maps to FRs**: FR-036 through FR-041

**Content Elements**:

- **MCP fundamentals recap** (5-10 min): What MCP provides (from Chapter 37 preview)
- **MCPServerStreamableHttp** (15-20 min): Connect to remote MCP server with URL + headers
- **Context7 integration** (15-20 min): Connect to Context7 MCP server for documentation lookup
- **Agent with MCP tools** (15-20 min): Configure agent with `mcp_servers=[server]`
- **Async context manager** (10-15 min): Proper lifecycle management with `async with`
- **Practical example** (15-20 min): TaskManager agent getting library documentation via Context7
- **Skill creation** (15-20 min): Encapsulate MCP integration pattern as reusable `mcp-agent-integration` skill

**Reusable Skill Created**:

- **Skill**: `mcp-agent-integration`
- **Persona**: Integration architect
- **Questions**: Which MCP servers needed? What tools do they provide? How to manage lifecycle?
- **Principles**: Async context managers for lifecycle, headers for auth, tool discovery before use

**Prerequisites**: Lessons 1-7

**Estimated Time**: 90-110 minutes

---

### Lesson 9: RAG with FileSearchTool (Layer 3: Intelligence Design)

**Learning Objective**: Implement agentic RAG pattern where agents decide when to retrieve from vector stores using FileSearchTool

**Stage**: Layer 3 (Intelligence Design — create reusable skill)

**CEFR Proficiency**: C1

**New Concepts** (count: 5):

1. `FileSearchTool` for vector store retrieval
2. `vector_store_ids` configuration
3. `max_num_results` parameter for controlling retrieval
4. Agentic RAG pattern (agent decides when to retrieve)
5. Grounded responses from retrieved content

**Cognitive Load Validation**: 5 new concepts (C1 allows higher complexity) → ACCEPTABLE

**Maps to Evals**: SC-009 (implement agentic RAG with FileSearchTool)
**Maps to FRs**: FR-042 through FR-047

**Content Elements**:

- **RAG fundamentals recap** (5-10 min): Why retrieval matters for agents
- **OpenAI vector stores** (10-15 min): Create vector store via dashboard or API
- **FileSearchTool configuration** (15-20 min): Configure with vector_store_ids and max_num_results
- **Agentic RAG pattern** (15-20 min): Agent decides when to call FileSearchTool
- **Grounded responses** (10-15 min): How agent uses retrieved content
- **Practical example** (15-20 min): TaskManager agent with project knowledge base
- **Skill creation** (15-20 min): Encapsulate RAG pattern as reusable `agentic-rag-integration` skill

**Reusable Skill Created**:

- **Skill**: `agentic-rag-integration`
- **Persona**: Knowledge architect
- **Questions**: What knowledge needs retrieval? How many results optimal? When should agent retrieve?
- **Principles**: Agentic retrieval (agent decides), grounded responses, appropriate chunk count

**Prerequisites**: Lessons 1-8

**Estimated Time**: 90-110 minutes

---

### Lesson 10: Capstone - Customer Support Digital FTE (Layer 4: Spec-Driven Integration)

**Learning Objective**: Implement production-quality Customer Support Digital FTE using specification-first approach, composing all patterns from Lessons 1-9, with monetization model articulation

**Stage**: Layer 4 (Spec-Driven Integration / Capstone)

**CEFR Proficiency**: C1 (advanced production systems)

**Maps to Evals**: ALL (SC-001 through SC-012 integrated)
**Maps to FRs**: FR-048 through FR-055

**Content Elements**:

#### Part 1: Specification Writing (PRIMARY SKILL — 25-35 min)

- Write spec.md for Customer Support Digital FTE
- Define: intent (24/7 support agent), constraints (quality, cost), success criteria
- Identify: information needs, handoff points, validation requirements
- **NO code yet (spec FIRST)**

**Spec Structure**:
```markdown
# Customer Support Digital FTE Specification

## Intent
24/7 customer support agent for airline operations

## Success Criteria
- Route FAQ questions to FAQ specialist
- Handle seat booking with context injection
- Detect and block abusive inputs
- Maintain conversation history across sessions
- Provide traceable interactions for debugging
- Integrate documentation via MCP
- Answer factual questions from FAQ knowledge base

## Constraints
- Response time < 3 seconds
- Token budget per conversation
- Safety guardrails active

## Components Required
- Triage agent (orchestrator)
- FAQ specialist agent
- Seat booking specialist agent
- Escalation agent
```

#### Part 2: Pattern Analysis (15-20 min)

Map Lessons 1-9 patterns to customer support requirements:

| Lesson | Pattern | Application |
|--------|---------|-------------|
| L1-L2 | SDK setup, context objects | AirlineAgentContext (passenger_name, confirmation_number, seat_number) |
| L3 | Orchestrator pattern | Triage coordinates FAQ/booking/escalation specialists |
| L4 | Handoffs with callbacks | Set flight_number on handoff to booking agent |
| L5 | Guardrails | Abuse detection, PII filtering |
| L6 | AdvancedSQLiteSession | Conversation history per customer |
| L7 | Tracing | Complete conversation trace with group_id |
| L8 | MCP Integration | Context7 for documentation lookup |
| L9 | RAG | FileSearchTool for FAQ knowledge base |

#### Part 3: Component Composition (20-25 min)

- Define all agents: triage_agent, faq_agent, seat_booking_agent, escalation_agent
- Define all tools: faq_lookup_tool, update_seat, escalate_to_human
- Map handoffs: triage ↔ FAQ, triage ↔ booking, booking/FAQ → escalation
- Design guardrails: input (abuse), output (verify seat exists)
- Plan session: AdvancedSQLiteSession per customer_id
- Integrate MCP: Context7 for documentation
- Integrate RAG: FileSearchTool for FAQ knowledge base

#### Part 4: AI Orchestration (with Three Roles) (40-50 min)

- Implement spec using accumulated patterns
- AI as Teacher: Suggests architectural improvements
- You as Student: Validate suggestions against spec
- Convergence: Iterate on implementation quality until spec ↔ code alignment
- Full conversation loop with `to_input_list()` and `result.last_agent`

#### Part 5: Validation (20-25 min)

- Test against spec success criteria
- Run conversation flows: FAQ → answer, booking → flight assignment, escalation trigger
- Verify: context persistence, message filtering, guardrail triggering, token tracking
- Generate trace, view in dashboard
- Test MCP integration (documentation lookup works)
- Test RAG integration (FAQ answers grounded in knowledge base)

#### Part 6: Monetization & Journey Reflection (15-20 min)

**Monetization Models Discussion**:

| Model | How It Works | Best For Customer Support FTE |
|-------|--------------|-------------------------------|
| **Subscription** | $500-2,000/mo for managed FTE | SMBs wanting hands-off automation |
| **Success Fee** | $5 per resolved ticket | High-volume, aligned incentives |
| **Hybrid** | Base subscription + success bonus | Enterprise with SLAs |

**Questions to consider**:
- What's your target customer?
- How do you price for value delivered?
- What SLAs can you offer?

**What's Next (SC-012)**:

- **Ch42 (DISTRIBUTE)**: Package this agent for ChatGPT marketplace (800M+ users)
- **Part 7 (DEPLOY)**: Kubernetes, scaling, monitoring for production

#### Part 7: Final Reflection (10-15 min)

- How did patterns from Lessons 1-9 compose into this FTE?
- How did spec-first design guide implementation differently?
- How would you monetize this as a Digital FTE?
- What's your plan for DISTRIBUTE and DEPLOY phases?

**Prerequisites**: Lessons 1-9 (all accumulated knowledge)

**Estimated Time**: 150-180 minutes (2.5-3 hours — substantial capstone)

---

## IV. 4-Layer Progression Validation

| Layer | Lessons | Description | Validation |
|-------|---------|-------------|------------|
| **Layer 1 (Manual)** | L1-L2 | SDK primitives, basic patterns without AI | No AI collaboration, students type manually |
| **Layer 2 (AI Collab)** | L3-L7 | Three Roles demonstrations (invisible) | Each lesson has Try With AI with Teacher/Student/Co-Worker |
| **Layer 3 (Intelligence)** | L8-L9 | Create reusable skills from patterns | MCP skill + RAG skill created |
| **Layer 4 (Spec-Driven)** | L10 | Capstone with spec-first orchestration | Spec written BEFORE code |

**Stage Progression Checklist**:

- [x] Lessons 1-2: Layer 1 (Manual, no AI) - No "Tell AI" in L1-L2
- [x] Lessons 3-7: Layer 2 (AI Collab with Three Roles) - Each has Teacher/Student/Co-Worker
- [x] Lessons 8-9: Layer 3 (Intelligence Design) - Reusable skills created
- [x] Lesson 10: Layer 4 (Spec-Driven Integration) - Spec FIRST, then code
- [x] No spec-first before Layer 4 - Validated

---

## V. Skills & Intelligence Design (Layer 3)

### Reusable Skills Created

**From Lesson 3 (Agents as Tools)**:
- **Skill**: `orchestrator-multi-agent-pattern`
- Encapsulates: agent.as_tool(), custom_output_extractor, orchestration strategy
- Applies to: Any multi-agent system

**From Lesson 4 (Handoffs)**:
- **Skill**: `handoff-with-context-injection`
- Encapsulates: handoff(), on_handoff callback, message filtering
- Applies to: Any specialist handoff scenario

**From Lesson 5 (Guardrails)**:
- **Skill**: `agent-based-guardrail-validation`
- Encapsulates: @input_guardrail, agent-based reasoning, structured output
- Applies to: PII detection, abuse detection, topic validation

**From Lesson 6 (Sessions)**:
- **Skill**: `conversation-persistence-and-branching`
- Encapsulates: AdvancedSQLiteSession, branching logic, history retrieval
- Applies to: Any agent with conversation memory needs

**From Lesson 7 (Tracing)**:
- **Skill**: `production-observability-stack`
- Encapsulates: RunHooks + tracing + group_id correlation + token tracking
- Applies to: Any production agent requiring observability

**From Lesson 8 (MCP Integration)**:
- **Skill**: `mcp-agent-integration`
- Encapsulates: MCPServerStreamableHttp, async lifecycle, tool discovery
- Applies to: Any agent needing external tool ecosystems

**From Lesson 9 (RAG)**:
- **Skill**: `agentic-rag-integration`
- Encapsulates: FileSearchTool, vector stores, agent-driven retrieval
- Applies to: Any agent needing knowledge base access

**Total Skills**: 7 reusable skills for Digital FTE toolkit

---

## VI. Running Example: TaskManager Agent

**Continuation from Chapter 33**: Extends conceptual framework into production implementation

**Escalation across lessons**:

| Lesson | TaskManager Evolution |
|--------|----------------------|
| L1 | Basic setup + hello world |
| L2 | Context objects with TaskManagerContext (user_id, current_project, tasks_added) |
| L3 | Multi-agent orchestrator (planning/execution/validation specialists) |
| L4 | Handoffs between agents with context injection |
| L5 | Guardrails for task validation (no PII in task names) |
| L6 | Session persistence per user with branching |
| L7 | Tracing and observability infrastructure |
| L8 | MCP integration for documentation lookup |
| L9 | RAG integration for project knowledge base |
| L10 | Capstone transforms to Customer Support FTE (airline domain) |

---

## VII. Assessment Plan

### Formative Assessments (During Lessons)

| Lesson | Assessment | Maps to Eval |
|--------|-----------|--------------|
| L1 | SDK setup verification quiz | — |
| L2 | Context object implementation exercise | SC-001 |
| L3 | Orchestrator with 3+ agents exercise | SC-002 |
| L4 | Bidirectional handoff implementation | SC-003 |
| L5 | Agent-based guardrail implementation | SC-004 |
| L6 | Conversation branching exercise | SC-005 |
| L7 | Full observability stack implementation | SC-006, SC-007 |
| L8 | MCP integration with Context7 | SC-008 |
| L9 | RAG with FileSearchTool | SC-009 |

### Summative Assessment (Capstone)

**Lesson 10 Capstone**: Complete Customer Support Digital FTE meeting all spec criteria

| Criterion | Weight | Success Indicator |
|-----------|--------|-------------------|
| Specification Quality | 15% | Clear intent, constraints, success criteria written FIRST |
| Pattern Integration | 40% | All L1-L9 patterns applied correctly |
| MCP + RAG Integration | 15% | Documentation and FAQ knowledge base working |
| Monetization Articulation | 10% | Clear model choice with rationale |
| Journey Understanding | 10% | Can explain BUILD → DISTRIBUTE → DEPLOY |
| Code Quality | 10% | Type hints, tests, clean architecture |

**Proficiency Levels**:
- **B2 competence**: Core patterns implemented, basic functionality
- **C1 mastery**: All patterns integrated, production-quality code
- **C1+ excellence**: Goes beyond requirements with custom innovations

---

## VIII. Cognitive Load Distribution

| Lesson | New Concepts | Cumulative | CEFR Limit | Status |
|--------|--------------|------------|------------|--------|
| L1 | 6 | 6 | B1: 10 | ✓ Within |
| L2 | 7 | 13 | B1: 10 | ✓ Within (L2) |
| L3 | 5 | 18 | B1-B2: 10 | ✓ Within |
| L4 | 6 | 24 | B1-B2: 10 | ✓ Within |
| L5 | 6 | 30 | B2: 10 | ✓ Within |
| L6 | 6 | 36 | B2: 10 | ✓ Within |
| L7 | 7 | 43 | B2-C1: 10 | ✓ Within |
| L8 | 5 | 48 | C1: higher | ✓ Acceptable |
| L9 | 5 | 53 | C1: higher | ✓ Acceptable |
| L10 | 0 (integration) | 53 | C1 | ✓ Synthesis |

**Note**: Lessons 8-9 are Layer 3 (intelligence design) at C1 proficiency where students have higher autonomy.

---

## IX. Teaching Modality Variation (Anti-Convergence)

| Lesson | Modality | Why |
|--------|----------|-----|
| L1 | Step-by-Step Walkthrough | First exposure, fixed setup steps |
| L2 | Hands-On Discovery | Build by doing, observe mutations |
| L3 | Specification-First | Design orchestrator before implementing |
| L4 | Collaborative Debugging | Debug handoff issues iteratively |
| L5 | Error Analysis | Show attack, design defense |
| L6 | Comparative Analysis | SQLiteSession vs AdvancedSQLiteSession |
| L7 | Hands-On Observability | Build traces, view dashboard |
| L8 | Integration Patterns | Connect to external MCP ecosystem |
| L9 | Knowledge Architecture | Design retrieval strategy |
| L10 | Capstone Project | Spec-first synthesis |

**No two consecutive lessons repeat modality** — prevents convergence on familiar patterns.

---

## X. Implementation Handoff

### For content-implementer subagent

1. All code examples must be executed against live OpenAI API with logs
2. Three Roles demonstrations (L3-L7 lessons) must show all three roles explicitly WITHOUT meta-commentary
3. Running TaskManager example maintained consistently across L1-L9
4. Customer Support FTE in L10 uses airline domain (AirlineAgentContext)
5. Full type hints required in all code samples
6. Fact-checked against official openai-agents documentation
7. LiteLLM alternative shown in Lesson 1
8. MCP integration uses Context7 as primary example
9. RAG uses OpenAI hosted vector stores

### For validation-auditor subagent

1. Verify Layer progression (L1-L2: Manual → L3-L7: AI Collab → L8-L9: Intelligence → L10: Spec-Driven)
2. Check Three Roles presence in all Layer 2 lessons (L3-L7)
3. Verify zero meta-commentary violations (grep for "Layer", "Stage", "What to notice", "AI as Teacher/Student/Co-Worker")
4. Validate cognitive load ≤ tier limits per lesson
5. Confirm all 12 success evals mapped to lesson content
6. Validate capstone spec includes intent, constraints, success criteria
7. Verify MCP integration in L8 and capstone
8. Verify RAG integration in L9 and capstone
9. Verify monetization discussion in capstone
10. Verify "What's Next" points to Ch42 and Part 7

### For technical-reviewer subagent

1. Execute all code examples (test logs required)
2. Verify OpenAI Agents SDK APIs against current docs
3. Test MCPServerStreamableHttp with real MCP server
4. Test FileSearchTool with real vector store
5. Fact-check all claims (sources documented)
6. Test TaskManager examples across all lessons
7. Test Customer Support FTE capstone end-to-end

---

## XI. Success Metrics

### Technical Quality

- [ ] All 10 lessons implement in specified timeframes
- [ ] Layer 1 → Layer 2 → Layer 3 → Layer 4 progression validated
- [ ] Three Roles demonstrated in every Layer 2 lesson (L3-L7) with real patterns
- [ ] All code examples tested against live API
- [ ] All 12 success evals (SC-001 through SC-012) assessable through lessons
- [ ] MCP integration working with Context7
- [ ] RAG integration working with FileSearchTool

### Pedagogical Quality

- [ ] TaskManager running example consistent across L1-L9
- [ ] 90%+ first-pass validation success rate
- [ ] Cognitive load respects CEFR limits per lesson
- [ ] Capstone produces deployment-ready Digital FTE
- [ ] Monetization models clearly articulated
- [ ] BUILD → DISTRIBUTE → DEPLOY journey understood

### Digital FTE Journey

- [ ] Students understand Chapter 34 = BUILD phase
- [ ] Students know Chapter 42 = DISTRIBUTE phase
- [ ] Students know Part 7 = DEPLOY phase
- [ ] Students can articulate monetization model for their FTE

---

## XII. Dependency Map

### Skill Dependencies (from Chapter 33)

**Concepts students bring from Chapter 33**:
- 5-Level Agent Taxonomy
- 3+1 Architecture
- 5-Step Loop
- Multi-agent patterns (Coordinator, Sequential, Iterative, Human-in-the-Loop)
- Agent Ops concepts (evaluation, tracing, golden datasets)

### Part 5 Dependencies

**Concepts students bring from Part 5**:
- Python async/await (Chapter 31)
- Type hints (throughout)
- Pydantic models (Chapter 30)
- Exception handling (Chapter 24)
- File handling (Chapter 25)

### Cross-Chapter Dependencies

| Chapter 34 Concept | Requires From |
|--------------------|---------------|
| Context objects | Part 5: Pydantic (Ch30) |
| Async execution | Part 5: Asyncio (Ch31) |
| Agent taxonomy | Ch33: 5-Level Taxonomy |
| Orchestration patterns | Ch33: Multi-agent patterns |

---

## XIII. File Structure

```
apps/learn-app/docs/06-AI-Native-Software-Development/34-openai-agents-sdk/
├── README.md                           # Chapter overview (exists)
├── 00-build-your-openai-agents-skill.md # L0: Skill-First (exists)
├── 01-sdk-setup-first-agent.md         # L1: SDK Setup (exists, needs update)
├── 02-function-tools-context.md        # L2: Function Tools (exists, needs update)
├── 03-agents-as-tools.md               # L3: Agents as Tools (exists, needs update)
├── 04-handoffs-filtering.md            # L4: Handoffs (exists, needs update)
├── 05-guardrails-validation.md         # L5: Guardrails (exists, needs update)
├── 06-sessions-memory.md               # L6: Sessions (exists, needs update)
├── 07-tracing-observability.md         # L7: Tracing (exists, needs update)
├── 08-mcp-integration.md               # L8: MCP Integration (NEW)
├── 09-rag-filesearch.md                # L9: RAG (NEW)
├── 10-capstone-customer-support.md     # L10: Capstone (exists, needs major update)
└── quiz.md                             # Chapter quiz (exists)
```

---

**Plan complete. Ready for /sp.implement with lesson writer and validators.**

**Key Updates from Previous Plan**:
1. Expanded from 8 to 10 lessons
2. Added L8: MCP Integration (SC-008, FR-036-041)
3. Added L9: RAG with FileSearchTool (SC-009, FR-042-047)
4. Added SC-011 (monetization) and SC-012 (journey understanding) to capstone
5. Enhanced capstone with MCP + RAG integration
6. Added BUILD → DISTRIBUTE → DEPLOY journey framing
7. Updated skill creation to include mcp-agent-integration and agentic-rag-integration
