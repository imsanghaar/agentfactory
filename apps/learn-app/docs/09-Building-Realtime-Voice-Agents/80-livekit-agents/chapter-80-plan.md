# Chapter 80: LiveKit Agents - Lesson Plan

**Generated by**: chapter-planner v2.0.0 (Reasoning-Activated)
**Source**: Part 11 README, Deep Search Report, Chapter 79 context
**Created**: 2026-01-01
**Constitution**: v6.0.0 (Reasoning Mode)

---

## I. Chapter Analysis

### Chapter Type

**TECHNICAL (SKILL-FIRST L00 Pattern)** - This chapter uses the Skill-First Learning pattern where students build the `livekit-agents` skill FIRST from official documentation, then learn the framework by improving that skill across subsequent lessons.

**Recognition signals**:
- Learning objectives use "implement/create/build/deploy"
- Code examples required for every lesson
- Skill artifact created in Lesson 0
- Subsequent lessons TEST and IMPROVE the skill
- Follows L00 pattern established in Parts 5-7

### Concept Density Analysis

**Core Concepts** (from Deep Search + Part 11 README): 10 concepts

1. LEARNING-SPEC.md (skill specification before building)
2. LiveKit Agents architecture (Agents, AgentSessions, Workers)
3. Job scheduling and lifecycle management
4. WebRTC integration for realtime audio
5. Voice pipeline configuration (STT, TTS, LLM)
6. Semantic turn detection with transformer models
7. Barge-in and interruption handling
8. MCP server integration for tools
9. Multi-agent handoff patterns
10. Kubernetes deployment for production

**Complexity Assessment**: Standard-Complex (production framework with distributed concepts)

**Proficiency Tier**: B1-B2 (Part 11 requires Parts 6, 7, 9, 10 completed; students have production experience)

**Justified Lesson Count**: 4 lessons
- Lesson 0: Build Your LiveKit Agents Skill (L00 pattern)
- Lesson 1: LiveKit Architecture Deep Dive (Layer 2: AI Collaboration)
- Lesson 2: Semantic Turn Detection & MCP Integration (Layer 2)
- Lesson 3: Multi-Agent Handoff & Production Deployment (Layer 3 + Layer 4 elements)

**Reasoning**:
- 10 concepts across 4 lessons = 2.5 concepts per lesson
- B1-B2 limit is 10 concepts per lesson - well within limit
- L00 pattern requires skill-first approach
- Capstone for Part 11 is Chapter 85, so Chapter 80 focuses on skill improvement, not full capstone

---

## II. Success Evals (from Part 11 README + Chapter 80 Description)

**Success Criteria** (what students must achieve):

1. **Skill Creation**: Students build a working `livekit-agents` skill from official documentation using /fetching-library-docs
2. **Architecture Understanding**: Students can explain Agents, AgentSessions, Workers architecture and when each component applies
3. **Voice Pipeline Implementation**: Students implement a working voice agent with STT, LLM, TTS components
4. **Turn Detection Mastery**: Students configure semantic turn detection and handle barge-in interruptions correctly
5. **MCP Integration**: Students connect MCP servers to voice agents with single-line configuration
6. **Multi-Agent Handoff**: Students implement triage agent to specialist agent handoffs with context preservation
7. **Production Readiness**: Students deploy voice agents to Kubernetes with proper session management

**All lessons below map to these evals.**

---

## III. Lesson Sequence

---

### Lesson 0: Build Your LiveKit Agents Skill

**Title**: Build Your LiveKit Agents Skill

**Learning Objectives**:
- Write a LEARNING-SPEC.md that defines what you want to learn about LiveKit Agents
- Fetch official LiveKit Agents documentation using /fetching-library-docs
- Create a `livekit-agents` skill grounded in official documentation (not AI memory)
- Verify the skill works by building a minimal voice agent

**Stage**: Layer 1 (Manual Foundation) + Layer 2 (AI Collaboration via /skill-creator)

**CEFR Proficiency**: B1

**New Concepts** (count: 2):
1. LEARNING-SPEC.md (specification before skill creation)
2. Documentation-grounded skill creation

**Cognitive Load Validation**: 2 concepts &lt;= 10 limit (B1) -> WITHIN LIMIT

**Maps to Evals**: #1 (Skill Creation)

**Key Sections**:

1. **Clone the Skills Lab Fresh** (~3 min)
   - Why fresh clone: No state assumptions from previous work
   - Command: `git clone [skills-lab-repo] && cd skills-lab`
   - Verify clean environment

2. **Write Your LEARNING-SPEC.md** (~7 min)
   - What is LEARNING-SPEC.md: Your specification for what you want to learn
   - Template structure:
     ```markdown
     # Learning Specification: LiveKit Agents

     ## What I Want to Learn
     - How LiveKit Agents architecture works (Agents, Sessions, Workers)
     - How to build voice agents with turn detection
     - How to integrate MCP servers for tools
     - How to deploy to Kubernetes

     ## Why This Matters
     - LiveKit powers ChatGPT's Advanced Voice Mode
     - Need production-grade voice infrastructure for Digital FTEs

     ## Success Criteria
     - [ ] Skill can scaffold a basic voice agent
     - [ ] Skill explains architecture decisions
     - [ ] Skill guides MCP integration
     - [ ] Skill includes deployment patterns
     ```
   - Write YOUR specification (not a copy)

3. **Fetch Official Documentation** (~5 min)
   - Use /fetching-library-docs to get LiveKit Agents docs
   - Why official docs: AI memory is unreliable for API details
   - What to look for: Architecture overview, quickstart, API reference
   - Save relevant excerpts for skill creation

4. **Create Your Skill with /skill-creator** (~10 min)
   - Invoke /skill-creator with your LEARNING-SPEC.md and fetched docs
   - Skill structure: Persona + Questions + Principles
   - Review generated skill for accuracy
   - Commit to `.claude/skills/livekit-agents/SKILL.md`

5. **Verify Your Skill Works** (~5 min)
   - Test: "Create a minimal LiveKit voice agent"
   - Verify generated code matches official patterns
   - If issues found: Improve skill and re-test
   - Skill is now your knowledge artifact

**Duration Estimate**: 30 minutes

**File Output**: `.claude/skills/livekit-agents/SKILL.md`

**Prerequisites**:
- Part 10 completed (chat interfaces)
- Chapter 79 completed (voice AI fundamentals)

**Try With AI Prompts**:

1. **Draft Your LEARNING-SPEC.md**
   ```
   I'm about to learn LiveKit Agents, the framework powering ChatGPT's
   Advanced Voice Mode. Help me write a LEARNING-SPEC.md:

   My context:
   - I've built chat interfaces in Part 10
   - I understand voice AI fundamentals from Chapter 79
   - My goal is to add voice to my Task Manager Digital FTE

   Help me define:
   1. What specific aspects of LiveKit should I focus on?
   2. What success criteria would prove I've learned it?
   3. What should I explicitly NOT focus on (scope boundary)?

   Make this MY specification, not a generic template.
   ```
   **What you're learning**: Specification as the primary skill - defining what you want to learn BEFORE learning it.

2. **Analyze the Official Docs**
   ```
   I fetched LiveKit Agents documentation. Here are the key sections:
   [paste relevant excerpts from /fetching-library-docs output]

   Help me understand:
   1. What's the core architecture? (Agents, Sessions, Workers)
   2. What patterns appear repeatedly in the examples?
   3. What concepts should my skill definitely include?
   4. What's unique about LiveKit vs generic voice agent frameworks?

   I want to build a GROUNDED skill, not one based on assumptions.
   ```
   **What you're learning**: Documentation analysis - extracting patterns from primary sources.

3. **Review Your Generated Skill**
   ```
   Here's the skill /skill-creator generated:
   [paste SKILL.md content]

   Compare this to the official documentation:
   1. Does it accurately represent LiveKit's architecture?
   2. Are there any claims not supported by the docs?
   3. What's missing that should be included?
   4. What should be removed as incorrect or speculative?

   Help me make this skill ACCURATE, not just comprehensive.
   ```
   **What you're learning**: Validation - ensuring AI-generated content matches authoritative sources.

---

### Lesson 1: LiveKit Architecture

**Title**: LiveKit Architecture Deep Dive

**Learning Objectives**:
- Explain the Agents, AgentSessions, Workers architecture and their relationships
- Implement job scheduling and lifecycle management for voice agents
- Configure WebRTC integration for realtime audio streaming
- Build a voice agent with proper STT, LLM, TTS pipeline

**Stage**: Layer 2 (AI Collaboration) - Use skill to build, improve skill based on learnings

**CEFR Proficiency**: B1

**New Concepts** (count: 3):
1. LiveKit architecture (Agents, AgentSessions, Workers)
2. Job scheduling and lifecycle
3. WebRTC audio streaming integration

**Cognitive Load Validation**: 3 concepts &lt;= 10 limit (B1) -> WITHIN LIMIT

**Maps to Evals**: #2 (Architecture Understanding), #3 (Voice Pipeline Implementation)

**Key Sections**:

1. **The Three-Layer Architecture** (~7 min)
   - **Agents**: Your application logic - what the voice assistant does
   - **AgentSessions**: Individual conversations with state and context
   - **Workers**: Processes that run agents, horizontally scalable
   - Why separation matters: Scale, reliability, state management
   - Diagram: How components interact

2. **Job Scheduling and Lifecycle** (~8 min)
   - Job types: `entrypoint`, `prewarm`, `on_shutdown`
   - Lifecycle events: When jobs start, run, complete
   - Worker pool management: How jobs are distributed
   - Graceful shutdown: Preserving session state
   - Code: Implementing job handlers

3. **WebRTC Integration** (~7 min)
   - LiveKit Rooms: Audio/video spaces for interaction
   - Track subscription: How agents receive audio
   - Publishing audio: How agents speak to users
   - NAT traversal: How WebRTC handles network complexity
   - Code: Connecting to a LiveKit room

4. **Voice Pipeline Configuration** (~8 min)
   - STT options: Deepgram, Whisper, AssemblyAI
   - LLM integration: OpenAI, Anthropic, local models
   - TTS options: Cartesia, ElevenLabs, Deepgram Aura
   - Configuration patterns: Swapping providers
   - Code: Complete voice agent pipeline

5. **Improve Your Skill** (~5 min)
   - Reflect: What architecture patterns did you learn?
   - Update `.claude/skills/livekit-agents/SKILL.md`
   - Add: Architecture decision guidance
   - Test: Does improved skill generate better code?

**Duration Estimate**: 35 minutes

**Three Roles Integration** (Layer 2):

**AI as Teacher**:
- Skill suggests job lifecycle patterns you didn't know
- "For graceful shutdown, use the on_shutdown handler to save session state to Redis"

**AI as Student**:
- You refine skill's architecture explanation based on your learnings
- "The Workers section needs more detail about horizontal scaling"

**AI as Co-Worker**:
- Iterate on voice pipeline code together
- First attempt misses audio format conversion -> AI suggests fix -> you validate

**Try With AI Prompts**:

1. **Understand the Architecture**
   ```
   I'm learning LiveKit's Agents, AgentSessions, Workers architecture.
   Use my livekit-agents skill to help me understand:

   1. When does an Agent become an AgentSession?
   2. How do Workers distribute jobs across machines?
   3. What state lives where? (Agent vs Session vs Worker)
   4. How does this differ from a simple single-process voice agent?

   Use diagrams or pseudocode to clarify the relationships.
   ```
   **What you're learning**: Distributed systems thinking - understanding component boundaries.

2. **Build a Voice Pipeline**
   ```
   Help me build a complete voice agent pipeline using my livekit-agents skill:

   Requirements:
   - STT: Deepgram Nova-3 (for low latency)
   - LLM: GPT-4o-mini (for cost efficiency)
   - TTS: Cartesia Sonic (for natural voice)
   - WebRTC: Via LiveKit room

   Walk me through the code step by step. After we build it, I'll tell
   you what works and what doesn't - then we'll iterate.
   ```
   **What you're learning**: Iterative implementation - building through conversation, not just code generation.

3. **Improve Your Skill**
   ```
   Based on what I learned about LiveKit architecture, here's what my
   livekit-agents skill is missing:

   [describe gaps you discovered]

   Help me update the skill to include:
   1. Architecture decision guidance (when to use which component)
   2. Job lifecycle patterns (entrypoint, prewarm, shutdown)
   3. Common pitfalls I encountered

   The goal is making the skill MORE USEFUL for future projects.
   ```
   **What you're learning**: Skill evolution - treating skills as living artifacts that improve with use.

---

### Lesson 2: Semantic Turn Detection & MCP Integration

**Title**: Semantic Turn Detection & MCP Integration

**Learning Objectives**:
- Configure semantic turn detection with transformer models
- Handle barge-in interruptions correctly (user speaks while agent speaking)
- Distinguish turn detection approaches: silence-based vs semantic
- Integrate MCP servers with single-line configuration
- Connect existing tools (file system, database) to voice agents

**Stage**: Layer 2 (AI Collaboration) - Advanced features, skill improvement

**CEFR Proficiency**: B1-B2

**New Concepts** (count: 3):
1. Semantic turn detection (transformer-based endpointing)
2. Barge-in and interruption handling
3. MCP server integration for voice

**Cognitive Load Validation**: 3 concepts &lt;= 10 limit (B1-B2) -> WITHIN LIMIT

**Maps to Evals**: #4 (Turn Detection Mastery), #5 (MCP Integration)

**Key Sections**:

1. **The Turn Detection Problem** (~5 min)
   - Why turn detection matters: When does user stop talking?
   - The pause problem: "Let me think..." vs end of sentence
   - User frustration: Agent interrupts mid-thought
   - Business impact: Poor turn detection = poor user experience

2. **Semantic Turn Detection** (~10 min)
   - How it works: Transformer model analyzes semantic completion
   - Beyond silence: Understanding sentence structure
   - LiveKit's implementation: Built-in semantic detector
   - Configuration: Sensitivity, timeout, model selection
   - Comparison: 40-60% fewer unwanted interruptions
   - Code: Enabling and tuning semantic detection

3. **Barge-In Handling** (~8 min)
   - What is barge-in: User speaks while agent is speaking
   - Detection: Recognizing user interruption
   - Response: Stop speaking, listen, respond
   - State management: Partial responses, context preservation
   - Code: Implementing barge-in handlers

4. **MCP Integration** (~10 min)
   - The one-line pattern: `agent.add_mcp_server(server_path)`
   - What this enables: Existing tools work via voice
   - Example: File system MCP -> "Read my config file"
   - Example: Database MCP -> "How many tasks are overdue?"
   - Tool calling: How voice agent invokes MCP tools
   - Code: Connecting Task Manager's MCP server to voice

5. **Improve Your Skill** (~5 min)
   - Reflect: What turn detection patterns did you learn?
   - Update skill: Add MCP integration guidance
   - Test: Can skill guide MCP connection correctly?

**Duration Estimate**: 38 minutes

**Three Roles Integration** (Layer 2):

**AI as Teacher**:
- Skill explains semantic turn detection model architecture
- "The transformer evaluates syntactic completeness, not just silence duration"

**AI as Student**:
- You provide context about your use case for barge-in tuning
- "My users speak slowly - increase the pause threshold"

**AI as Co-Worker**:
- Iterate on MCP integration until tools work via voice
- First attempt: Tool call fails -> debug together -> fix authorization

**Try With AI Prompts**:

1. **Configure Turn Detection**
   ```
   I want to configure semantic turn detection for my voice agent.
   Use my livekit-agents skill to help me:

   My use case:
   - Users often pause mid-sentence to think (5-7 second pauses)
   - False interruptions are very frustrating for my users
   - I'd rather have slight delays than interrupt incorrectly

   Help me configure:
   1. Turn detection sensitivity settings
   2. How to test if it's working correctly
   3. What metrics to monitor in production

   After we configure it, I'll test with real speech and report back.
   ```
   **What you're learning**: Configuration tuning - balancing latency vs accuracy for your specific context.

2. **Handle Barge-In Correctly**
   ```
   My voice agent needs to handle interruptions gracefully. When a user
   says "No wait, I meant..." while the agent is speaking, I want:

   1. Agent immediately stops speaking
   2. Agent listens to the correction
   3. Agent responds to the NEW request, not continues old response
   4. Partial response state is cleared

   Help me implement this using my livekit-agents skill. I'll test
   scenarios and tell you what's not working.
   ```
   **What you're learning**: Interruption handling - designing for natural conversation flow.

3. **Connect MCP Tools to Voice**
   ```
   I have an MCP server for my Task Manager that provides these tools:
   - list_tasks(status: str) -> Returns tasks by status
   - create_task(title: str, due: str) -> Creates new task
   - complete_task(id: str) -> Marks task complete

   Help me connect this to my LiveKit voice agent so users can say:
   "What tasks are due today?" or "Create a task to review proposal"

   Walk me through the integration step by step. I'll test each tool
   via voice and report what works.
   ```
   **What you're learning**: MCP-voice integration - bridging existing tools to conversational interfaces.

---

### Lesson 3: Multi-Agent Handoff & Production Deployment

**Title**: Multi-Agent Handoff & Production Deployment

**Learning Objectives**:
- Implement triage agent to specialist agent handoff patterns
- Preserve context across agent handoffs (user doesn't repeat themselves)
- Configure Kubernetes deployment for LiveKit voice agents
- Handle session persistence across pod restarts
- Finalize `livekit-agents` skill for production use

**Stage**: Layer 3 (Intelligence Design) + Layer 4 elements (production patterns)

**CEFR Proficiency**: B2

**New Concepts** (count: 2):
1. Multi-agent handoff with context preservation
2. Kubernetes deployment for voice agents

**Cognitive Load Validation**: 2 concepts &lt;= 10 limit (B2) -> WITHIN LIMIT

**Maps to Evals**: #6 (Multi-Agent Handoff), #7 (Production Readiness)

**Key Sections**:

1. **The Multi-Agent Pattern** (~8 min)
   - Why multi-agent: Specialized agents for different domains
   - Triage agent: Determines which specialist handles request
   - Specialist agents: Deep expertise in specific areas
   - Example: Support triage -> Billing specialist / Technical specialist
   - Diagram: Multi-agent flow

2. **Context Preservation** (~10 min)
   - The problem: User explains issue to triage, repeats to specialist
   - Solution: Pass conversation context in handoff
   - What to preserve: Full transcript, intent summary, user state
   - What NOT to preserve: Large binary data, stale context
   - Code: Implementing context-preserving handoff

3. **Handoff Implementation** (~10 min)
   - Detection: When to trigger handoff (intent classification)
   - Transition: Graceful agent switch (user notification)
   - Fallback: What if specialist unavailable?
   - Code: Complete triage -> specialist handoff

4. **Kubernetes Deployment** (~12 min)
   - Worker deployment: Horizontal pod autoscaling
   - Session persistence: Redis for session state
   - Pod restart handling: Reconnecting in-progress sessions
   - Load balancing: Sticky sessions for conversation continuity
   - Health checks: Liveness and readiness probes
   - Code: Kubernetes manifests for voice agent deployment

5. **Finalize Your Skill** (~5 min)
   - Complete skill review: Does it cover all learnings?
   - Production checklist: What guidance does skill need for deployment?
   - Final test: Use skill to scaffold a multi-agent voice system
   - Commit: Production-ready skill artifact

**Duration Estimate**: 45 minutes

**Three Roles Integration** (Layer 3 + Layer 4):

**AI as Teacher**:
- Skill guides multi-agent architecture decisions
- "For billing queries, handoff to billing-specialist with account context"

**AI as Student**:
- You teach skill your production deployment constraints
- "My Kubernetes cluster uses Istio - add service mesh patterns"

**AI as Co-Worker**:
- Design deployment architecture together
- You specify requirements -> AI generates manifests -> You validate in staging

**Skill Finalization**:
At lesson end, students have a production-ready `livekit-agents` skill that:
- Scaffolds voice agents with proper architecture
- Guides turn detection and MCP integration
- Includes multi-agent handoff patterns
- Provides Kubernetes deployment templates

**Try With AI Prompts**:

1. **Design Multi-Agent Handoff**
   ```
   I want to build a multi-agent voice system for customer support:

   - Triage Agent: Greets user, determines intent
   - Billing Specialist: Handles payments, invoices, refunds
   - Technical Specialist: Handles product issues, troubleshooting
   - Escalation Agent: Handles complex cases requiring human

   Use my livekit-agents skill to help me design:
   1. How does triage decide which specialist?
   2. What context passes in handoff?
   3. How does user experience the transition?
   4. What happens if specialist is overloaded?

   I'll implement and test, then report what works.
   ```
   **What you're learning**: Multi-agent architecture - designing for realistic support scenarios.

2. **Preserve Context Across Handoffs**
   ```
   My users are frustrated: They explain their issue to the triage
   agent, then have to repeat everything to the specialist.

   Help me implement context preservation:
   1. What exactly should transfer in the handoff?
   2. How does the specialist agent "know" the context?
   3. Should the specialist acknowledge the context?
      ("I see you're calling about your invoice from March...")

   Use my livekit-agents skill. I'll test with real conversations.
   ```
   **What you're learning**: User experience design - conversation continuity across agents.

3. **Deploy to Kubernetes**
   ```
   I'm ready to deploy my voice agent to Kubernetes. My constraints:

   - Cluster: [describe your K8s setup]
   - Scaling: Expect 100-500 concurrent sessions
   - Persistence: Redis available at [endpoint]
   - Observability: Prometheus + Grafana already running

   Use my livekit-agents skill to generate deployment manifests:
   1. Worker deployment with HPA
   2. Redis session persistence config
   3. Health checks and probes
   4. Service mesh / ingress config

   Walk me through deploying and validating each component.
   ```
   **What you're learning**: Production deployment - operating voice agents at scale.

---

## IV. Skill Dependency Graph

**Skill Dependencies**:

```
Lesson 0: Build Skill (foundation)
    ↓
Lesson 1: Architecture (requires skill)
    ↓
Lesson 2: Turn Detection + MCP (requires architecture understanding)
    ↓
Lesson 3: Multi-Agent + K8s (requires all previous)
```

**Cross-Chapter Dependencies**:
- Requires: Chapter 79 (Voice AI Fundamentals) - architecture mental models
- Requires: Part 7 (Cloud Native) - Kubernetes deployment patterns
- Requires: Part 10 (Frontends) - Chat interface patterns
- Prepares for: Chapter 81 (Pipecat) - alternative framework comparison
- Prepares for: Chapter 85 (Capstone) - production voice agent

---

## V. Assessment Plan

### Formative Assessments (During Lessons)

- **Lesson 0**: Skill generation verification (skill works, matches docs)
- **Lesson 1**: Voice pipeline code review (correct architecture)
- **Lesson 2**: Turn detection demo (handles mid-sentence pauses)
- **Lesson 3**: Multi-agent handoff test (context preserved)

### Summative Assessment (End of Chapter)

**Chapter 80 Quiz**:
1. Architecture: Explain Agents vs AgentSessions vs Workers
2. Turn Detection: Why semantic detection reduces interruptions
3. MCP Integration: How to connect existing tools to voice
4. Multi-Agent: Describe context preservation in handoffs
5. Deployment: Key considerations for Kubernetes voice agents

**Practical Assessment**:
- Deploy a multi-agent voice agent to Kubernetes
- Demonstrate semantic turn detection working correctly
- Show MCP tool invocation via voice

---

## VI. Validation Checklist

**Chapter-Level Validation**:
- [x] Chapter type identified: TECHNICAL (SKILL-FIRST L00 Pattern)
- [x] Concept density analysis documented: 10 concepts across 4 lessons
- [x] Lesson count justified: 4 lessons (~2.5 concepts each, within B1-B2 limit)
- [x] All evals covered by lessons
- [x] All lessons map to at least one eval

**Stage Progression Validation**:
- [x] Lesson 0: Layer 1 + Layer 2 (skill creation with AI collaboration)
- [x] Lessons 1-2: Layer 2 (AI collaboration, skill improvement)
- [x] Lesson 3: Layer 3 + Layer 4 elements (intelligence design, production patterns)
- [x] No premature spec-driven content (that's Chapter 85 Capstone)

**Cognitive Load Validation**:
- [x] Lesson 0: 2 concepts &lt;= 10 (B1 limit) PASS
- [x] Lesson 1: 3 concepts &lt;= 10 (B1 limit) PASS
- [x] Lesson 2: 3 concepts &lt;= 10 (B1-B2 limit) PASS
- [x] Lesson 3: 2 concepts &lt;= 10 (B2 limit) PASS

**L00 Pattern Requirements**:
- [x] Lesson 0 creates skill from official documentation
- [x] Fresh clone of skills-lab (no state assumptions)
- [x] LEARNING-SPEC.md written before skill creation
- [x] /fetching-library-docs used for documentation
- [x] Skill tested and verified before proceeding
- [x] Each subsequent lesson TESTS and IMPROVES the skill
- [x] "Improve Your Skill" section in each lesson

**Three Roles Validation** (Layer 2 lessons):
- [x] Each Layer 2 lesson demonstrates AI as Teacher
- [x] Each Layer 2 lesson demonstrates AI as Student
- [x] Each Layer 2 lesson demonstrates AI as Co-Worker (convergence)

**Canonical Source Validation**:
- [x] Skills format follows `.claude/skills/<name>/SKILL.md` pattern
- [x] Lesson 0 references /fetching-library-docs for official docs
- [x] Kubernetes patterns align with Part 7 canonical source

---

## VII. File Structure

```
62-livekit-agents/
├── _category_.json           # Existing
├── README.md                  # Chapter overview (create)
├── 00-build-your-skill.md     # Lesson 0: L00 pattern (create)
├── 01-livekit-architecture.md # Lesson 1 (create)
├── 02-turn-detection-mcp.md   # Lesson 2 (create)
├── 03-multi-agent-production.md # Lesson 3 (create)
└── 04-chapter-quiz.md         # Assessment (create)
```

---

## VIII. Summary

**Chapter 80: LiveKit Agents** is a 4-lesson SKILL-FIRST technical chapter:

| Lesson | Title | Concepts | Duration | Evals |
|--------|-------|----------|----------|-------|
| 0 | Build Your LiveKit Agents Skill | 2 | 30 min | #1 |
| 1 | LiveKit Architecture Deep Dive | 3 | 35 min | #2, #3 |
| 2 | Semantic Turn Detection & MCP | 3 | 38 min | #4, #5 |
| 3 | Multi-Agent Handoff & Production | 2 | 45 min | #6, #7 |

**Total**: 10 concepts, ~148 minutes, creates production-ready `livekit-agents` skill

**Skill Output**: `.claude/skills/livekit-agents/SKILL.md` - a reusable Digital FTE component grounded in official documentation.
