Agent Teams lets you coordinate multiple Claude Code instances as a team. Unlike subagents (Lesson 11) which are fire-and-forget workers that report back to a single caller, Agent Teams creates fully independent Claude sessions that communicate directly with each other through a shared task list and inter-agent messaging. Each teammate has its own clean context window, preventing the context degradation that happens when one agent tries to juggle multiple specialties. Teams support two display modes: in-process (all teammates in one terminal, navigated with Shift+Up/Down) and split-pane (each teammate in its own tmux/iTerm2 pane), configurable via `teammateMode` in settings or the `--teammate-mode` CLI flag.

The key capabilities include: TeamCreate for spawning teammates with specific roles, a shared task list (stored as JSON files in `~/.claude/tasks/`) with dependency chains that teammates self-coordinate around, direct messages between any teammates (not just to the lead), delegate mode (Shift+Tab) that forces the lead to coordinate rather than do the work itself, plan approval that requires teammates to get their approach reviewed before starting, shared documents for building consensus, and quality hooks (TeammateIdle, TaskCompleted) that enforce standards automatically. Behind the scenes, team config lives in `~/.claude/teams/{name}/config.json` and tasks are individual JSON files with `subject`, `status`, `blocks`, and `blockedBy` fields -- inspecting these files directly helps debug stuck teams.

Use Agent Teams when teammates need to talk to each other -- evaluating a business opportunity from multiple angles, investigating why customer satisfaction dropped with competing hypotheses where investigators debate each other's theories, or coordinating a product launch across marketing, operations, and finance. Use subagents when workers just need to report back -- summarizing a single report, researching one vendor, or drafting an email. The tradeoff is cost: teams use 3-5x more tokens because each teammate maintains a full context window, so the quality improvement from parallel focused investigation must justify the expense. Three universal patterns cover most use cases: parallel investigation (multiple angles on the same question), pipeline build (sequential dependencies where each stage feeds the next), and competing hypotheses (investigators actively trying to disprove each other to prevent anchoring bias).
